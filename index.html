<!DOCTYPE html>
<html lang="en">

<head>
  <title>Image Uploader Test</title>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
  <style>
    html {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      border: 0;
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="upload-idle" style="display: block">
    <div class="image-upload-block flex items-center justify-center flex-col">
      <h3 class="fw-semi text-black mt-0 mb-3">Upload photos here</h3>
      <p class="mb-0">Drop images here or select files</p>
    </div>
  </div>
  <div id="container">
    <div class="text-center auction-dropzone" ng-init="params = getUploadParams()">
      <!-- Calls To Action -->
      <button class="button small primary" id="file-upload-browse">Select Photos</button>
    </div>
  </div>
  <!-- Demo markup -->
  <textarea id="consoleSink" rows="12"
    style="width:100%;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></textarea>
  <script>
    /**
     * ConsoleToTextarea
     * Intercept console output and mirror it into a <textarea>.
     * 
     * Usage:
     *   const interceptor = new ConsoleToTextarea('consoleSink', { timestamps: true });
     *   interceptor.attach();
     *   console.log('Hello', { a: 1 });
     *   interceptor.detach(); // restores original console methods
     */
    class ConsoleToTextarea {
      /**
       * @param {string|HTMLTextAreaElement} textareaOrId - textarea id or element
       * @param {Object} [options]
       * @param {boolean} [options.timestamps=true] - prefix each line with ISO time
       * @param {boolean} [options.methodLabels=true] - include [log]/[warn]/etc.
       * @param {number}  [options.maxChars=200000] - trim textarea when it grows past this size
       * @param {string}  [options.separator=' '] - joiner between args when stringifying
       */
      constructor(textareaOrId, options = {}) {
        const el = typeof textareaOrId === 'string'
          ? document.getElementById(textareaOrId)
          : textareaOrId;

        if (!el || !(el instanceof HTMLTextAreaElement)) {
          throw new Error('ConsoleToTextarea: target must be a <textarea> or a valid textarea element id.');
        }

        this.textarea = el;
        this.options = {
          timestamps: options.timestamps !== false,
          methodLabels: options.methodLabels !== false,
          maxChars: Number.isFinite(options.maxChars) ? options.maxChars : 200000,
          separator: typeof options.separator === 'string' ? options.separator : ' ',
        };

        /** @type {Partial<Record<keyof Console, Function>>} */
        this._originals = {};
        this._attached = false;

        // Methods weâ€™ll proxy
        this._methods = /** @type {(keyof Console)[]} */ ([
          'log', 'info', 'warn', 'error', 'debug', 'dir', 'trace', 'clear', 'table'
        ]);
      }

      attach() {
        if (this._attached) return;
        const self = this;

        // Save originals only once
        this._methods.forEach((m) => {
          this._originals[m] = console[m] ? console[m].bind(console) : undefined;
        });

        // Helpers
        const write = (method, args) => self._write(method, args);
        const forward = (method, args) => {
          try { this._originals[method]?.(...args); } catch (_) { /* no-op */ }
        };

        // Install proxies
        console.log = function (...args) { write('log', args); forward('log', args); };
        console.info = function (...args) { write('info', args); forward('info', args); };
        console.warn = function (...args) { write('warn', args); forward('warn', args); };
        console.error = function (...args) { write('error', args); forward('error', args); };
        console.debug = function (...args) { write('debug', args); forward('debug', args); };
        console.dir = function (...args) { write('dir', args); forward('dir', args); };
        console.trace = function (...args) {
          // Build a synthetic trace text while still forwarding to the real console
          const err = new Error('trace');
          write('trace', args.length ? args : ['(trace)']);
          write('trace', [err.stack || '(no stack)']);
          forward('trace', args);
        };
        console.clear = () => {
          this.textarea.value = '';
          forward('clear', []);
        };
        console.table = (data, columns) => {
          // Basic text table rendering (keeps it simple)
          try {
            const tableText = this._renderTable(data, columns);
            write('table', [tableText]);
          } catch (e) {
            write('table', ['(unable to render table)']);
          }
          forward('table', [data, columns]);
        };

        this._attached = true;
      }

      detach() {
        if (!this._attached) return;
        // Restore originals
        Object.keys(this._originals).forEach((k) => {
          const key = /** @type {keyof Console} */ (k);
          if (this._originals[key]) console[key] = this._originals[key];
        });
        this._attached = false;
      }

      _write(method, args) {
        const { timestamps, methodLabels, separator, maxChars } = this.options;
        const prefixParts = [];
        if (timestamps) prefixParts.push(new Date().toISOString());
        if (methodLabels) prefixParts.push(`[${method}]`);
        const prefix = prefixParts.length ? prefixParts.join(' ') + ' ' : '';

        const text = args.map((a) => this._stringify(a)).join(separator);
        const line = prefix + text + '\n';

        // Append and trim if necessary
        const ta = this.textarea;
        const newVal = ta.value + line;
        if (newVal.length > maxChars) {
          // Trim from the start keeping the last ~90% to reduce frequent slicing
          const keep = Math.floor(maxChars * 0.9);
          ta.value = newVal.slice(newVal.length - keep);
        } else {
          ta.value = newVal;
        }
        // Scroll to bottom
        ta.scrollTop = ta.scrollHeight;
      }

      _stringify(value, depth = 0, seen = new WeakSet()) {
        const t = Object.prototype.toString.call(value);
        const maxDepth = 5;

        if (value === null || value === undefined) return String(value);
        if (typeof value === 'string') return value;
        if (typeof value === 'number' || typeof value === 'bigint' || typeof value === 'boolean') return String(value);
        if (typeof value === 'function') return `[Function ${value.name || 'anonymous'}]`;
        if (value instanceof Error) return `${value.name}: ${value.message}\n${value.stack || ''}`;
        if (value instanceof Node) return `[DOM ${value.nodeName}]`;
        if (value instanceof Date) return value.toISOString();
        if (value instanceof RegExp) return value.toString();

        // Prevent circular refs
        if (typeof value === 'object') {
          if (seen.has(value)) return '[Circular]';
          seen.add(value);
        }

        try {
          if (Array.isArray(value)) {
            if (depth >= maxDepth) return `[Array(${value.length})]`;
            const items = value.map(v => this._stringify(v, depth + 1, seen));
            return `[${items.join(', ')}]`;
          }

          // Plain objects and others
          if (depth >= maxDepth) return `[Object ${t}]`;
          const entries = Object.keys(value).map(k => `${k}: ${this._stringify(value[k], depth + 1, seen)}`);
          return `{ ${entries.join(', ')} }`;
        } catch {
          // Fallback to JSON where possible
          try { return JSON.stringify(value); } catch { return t; }
        }
      }

      _renderTable(data, columns) {
        // Create a simple text table (no fancy borders) suitable for a textarea
        const rows = [];
        const asArray = Array.isArray(data) ? data : (typeof data === 'object' && data != null ? Object.values(data) : []);

        const keys = columns && Array.isArray(columns) && columns.length
          ? columns
          : this._inferColumns(asArray);

        // Header
        rows.push(keys.join(' | '));
        rows.push(keys.map(k => '-'.repeat(String(k).length)).join('-|-'));

        // Body
        asArray.forEach(item => {
          const line = keys.map(k => {
            const v = item && typeof item === 'object' ? item[k] : undefined;
            return this._stringify(v);
          }).join(' | ');
          rows.push(line);
        });

        return rows.join('\n');
      }

      _inferColumns(arr) {
        const set = new Set();
        arr.slice(0, 50).forEach(obj => {
          if (obj && typeof obj === 'object') {
            Object.keys(obj).forEach(k => set.add(k));
          }
        });
        return Array.from(set);
      }
    }

    // --- Example usage (uncomment to try instantly) ---
    // const c = new ConsoleToTextarea('consoleSink', { timestamps: true });
    // c.attach();
    // console.log('Hello world', { a: 1, b: [1,2,3] });
    // console.warn('Careful!');
    // console.error(new Error('Boom!'));
    // console.table([{ a: 1, b: 2 }, { a: 3, b: 4 }]);
    // console.trace('where am I?');
    // setTimeout(() => c.detach(), 5000);

    const c = new ConsoleToTextarea('consoleSink', { timestamps: true });
    c.attach();
  </script>
  <script type="text/javascript" src="/eso-uploader-test/js/jquery.image_uploader.min.js"></script>

  <script type="text/javascript">
    var resizeOption = {
      width: 800,
      height: 800,
      quality: 90,
    };
    $(document).ready(function () {
      var uploader = $("#container").imageUploader({
        filters: {
          mime_types: [{ title: "Image files", extensions: "image/*" }],
          max_file_size: "150mb",
        },
        resize: resizeOption,
        dragDropEnabled: true,
        uploadUrl: "https://jsonplaceholder.typicode.com/posts", // Dummy URL for testing
        browseButton: "#file-upload-browse",
        dropElement: "#upload-idle",
        parallel: 6,
        transportMode: "POST",
        thumbnails: true,
        multipart: true,
        multipart_params: {
          listing_id: 0,
        },

        // Callback functions
        initialize: function () {
          $("#upload > .upload-block").bind({
            dragover: function () {
              $(this).addClass("active");
            },
            dragend: function () {
              $(this).removeClass("active");
            },
            dragleave: function () {
              $(this).removeClass("active");
            },
            drop: function () {
              $(this).removeClass("active");
            },
          });
        },
        onPreviewThumbnail: function (file, $canvas) {
          console.log(`Previewing thumbnail for ${file.name}`);
        },
        onBeforeQueue: function (files) {
          console.log("Before queueing files: ", files);
        },
        onS3FilePresign: function (file, media, _ticket) {
          console.log(`Presigning complete for S3 upload of file: ${file.name}`);
        },
        onBeforeUpload: function (file) {
          console.log("Before uploading file:", file.name);
        },
        onUploadProgress: function (file, progress, totals) {
          console.log(`Upload progress for ${file.name}: `, progress, totals);
        },
        onFileUploadComplete: function (file, response) {
          console.log(`Upload complete for ${file.name}:`, response);
        },
        onAllUploadsComplete: function (files) {
          console.log("All uploads complete.");
        },
        onFileError: function (file, error) {
          console.error(`Error uploading ${file.name}:`, error);
        },
      });
    });
  </script>
</body>

</html>