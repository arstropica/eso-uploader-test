{"version":3,"file":"jquery.image_uploader.min.js","mappings":"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","sources":["webpack://eso-uploader/./src/data/features/common.data.ts","webpack://eso-uploader/./src/libs/requestFactory.lib.ts","webpack://eso-uploader/./src/libs/imageReader.lib.ts","webpack://eso-uploader/./src/libs/imageUploader.lib.ts","webpack://eso-uploader/./src/jquery.image_uploader.ts","webpack://eso-uploader/./src/data/features/regex.data.ts","webpack://eso-uploader/./src/libs/imageTransformer.lib.ts","webpack://eso-uploader/./src/utils/functions.ts","webpack://eso-uploader/./src/libs/uploadPipeline.lib.ts","webpack://eso-uploader/./src/libs/imagePostRequest.lib.ts","webpack://eso-uploader/./src/data/uploader/defaults.data.ts","webpack://eso-uploader/./src/data/features/maps.data.ts","webpack://eso-uploader/./src/libs/thumbnailService.lib.ts","webpack://eso-uploader/./src/libs/extendedFile.lib.ts","webpack://eso-uploader/./src/libs/imageS3Request.lib.ts","webpack://eso-uploader/./src/libs/mimeReader.lib.ts","webpack://eso-uploader/./src/libs/uploadController.lib.ts","webpack://eso-uploader/./src/libs/features/uaparser.lib.ts","webpack://eso-uploader/./src/types/common.ts","webpack://eso-uploader/./src/types/window.ts","webpack://eso-uploader/./src/libs/imageRequest.lib.ts","webpack://eso-uploader/./src/libs/features/mapper.lib.ts","webpack://eso-uploader/./src/libs/extendedImage.lib.ts","webpack://eso-uploader/./src/libs/feature.lib.ts","webpack://eso-uploader/./src/console.logger.ts","webpack://eso-uploader/./src/libs/fileProcessor.lib.ts","webpack://eso-uploader/./src/libs/queueManager.lib.ts","webpack://eso-uploader/./src/plugins/registry.ts","webpack://eso-uploader/./src/libs/eventManager.lib.ts","webpack://eso-uploader/webpack/bootstrap","webpack://eso-uploader/webpack/startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VERSION = exports.NAME = exports.OBJ_TYPE = exports.UNDEF_TYPE = exports.FUNC_TYPE = exports.UNKNOWN = exports.EMPTY = void 0;\n/**\n * Common data constants used in Uploader.Feature\n */\nexports.EMPTY = \"\", exports.UNKNOWN = \"?\", exports.FUNC_TYPE = \"function\", exports.UNDEF_TYPE = \"undefined\", exports.OBJ_TYPE = \"object\", exports.NAME = \"name\", exports.VERSION = \"version\";\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UploadRequestFactory = void 0;\nconst imagePostRequest_lib_1 = require(\"./imagePostRequest.lib\");\nconst imageS3Request_lib_1 = require(\"./imageS3Request.lib\");\n/**\n * UploadRequestFactory class for creating upload request instances\n * @class UploadRequestFactory\n * @param {ImageUploaderSettings} settings - Configuration settings for the uploader\n * @constructor\n * @scope public\n */\nclass UploadRequestFactory {\n    constructor(settings) {\n        this.settings = settings;\n    }\n    /**\n     * Create a new upload request instance\n     * @param {S3PutTicket} [ticket] - Optional S3 PUT ticket for S3 uploads\n     * @returns {ImageRequest} - Returns a new instance of ImageRequest\n     * @throws {Error} - Throws an error if the transport mode is unsupported or if the S3 PUT ticket is missing\n     * @scope public\n     */\n    create(ticket) {\n        let request;\n        const transportMode = this.settings.transportMode || \"S3\";\n        switch (transportMode) {\n            case \"POST\":\n                request = new imagePostRequest_lib_1.ImagePostRequest(this.settings);\n                break;\n            case \"S3\":\n                if (typeof ticket === \"undefined\") {\n                    throw new Error(\"S3 transport mode requires a valid S3PutTicket.\");\n                }\n                request = new imageS3Request_lib_1.ImageS3Request(this.settings, ticket);\n                break;\n            default:\n                throw new Error(`Unsupported transport mode: ${transportMode}`);\n        }\n        return request;\n    }\n}\nexports.UploadRequestFactory = UploadRequestFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageReader = void 0;\nconst console_logger_1 = require(\"../console.logger\");\nconst functions_1 = require(\"../utils/functions\");\nconst mimeReader_lib_1 = require(\"./mimeReader.lib\");\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst feature_lib_1 = require(\"./feature.lib\");\n/**\n * ImageReader Class\n * @class ImageReader\n * @constructor\n * @description This class provides methods to decode images from various formats, including JPEG, PNG, and WebP.\n * It supports plugins for additional MIME types and handles EXIF orientation extraction.\n * The class is designed to work with both native browser capabilities and custom plugins for image decoding.\n * It can normalize input from strings (URLs), Files, or Blobs, and provides a unified interface for decoding images.\n * The decoded image is returned as a canvas element along with its orientation and metadata.\n */\nclass ImageReader {\n    /** Register a new plugin for a specific MIME type.\n     * @param {string} mimeType - The MIME type to register the plugin for.\n     * @param {ImageDecoderPluginFn} decoderFn - The function to decode the image format.\n     * @static\n     */\n    static registerPlugin(mimeType, decoderFn) {\n        ImageReader._plugins.push({ mimeType, decoderFn });\n    }\n    /** Decode an image from various input formats.\n     * @param {ImageInput} input - The image input to decode.\n     * @param {ImageLoadOptions} [options] - Options for decoding the image.\n     * @returns {Promise<ImageDecodeResult>} - The decoded image data.\n     * @throws {Error} If the input format is unsupported or an error occurs during decoding.\n     * @static\n     */\n    static async decode(input, options) {\n        const blob = await this._normalizeInput(input);\n        const mime = await mimeReader_lib_1.MimeReader.detectMime(blob);\n        // Try plugin decoders first\n        for (const { mimeType, decoderFn } of this._plugins) {\n            if (mime === mimeType) {\n                this._logger.debug(`Using plugin for MIME type: ${mimeType}`);\n                return this._decodePlugin(decoderFn, blob, options);\n            }\n        }\n        // Built-in formats\n        if (this._isNativeSupported(mime)) {\n            return this._maybeDecodeNative(blob, options);\n        }\n        throw new Error(`Unsupported image format: ${mime}`);\n    }\n    /**\n     * Get the EXIF data from a Blob.\n     * @param {Blob|File} blob - The Blob or File to extract EXIF data from.\n     * @returns {Promise<ImageMetadata>} - A promise that resolves with the EXIF data.\n     * @static\n     * @description This function reads the first 64KB of the Blob to find EXIF data.\n     * It uses a DataView to parse the binary data and extract the orientation tag (0x0112).\n     * If the EXIF orientation tag is found, it returns the orientation value; otherwise, it defaults to 1 (normal orientation).\n     */\n    static getEXIF(blob) {\n        const that = this;\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = function (e) {\n                let orientation = 1;\n                let rawEXIF;\n                let thumbnail;\n                try {\n                    const buffer = e.target.result;\n                    const view = new DataView(buffer);\n                    if (view.getUint16(0) !== 0xffd8) {\n                        return resolve({ orientation: 1 });\n                    }\n                    const exifData = that.__getRawEXIFData(view);\n                    if (!exifData) {\n                        return resolve({ orientation: 1 });\n                    }\n                    const { tiffOffset, littleEndian, rawEXIF: _rawEXIF, IFD0Offset, IFD1Offset } = exifData;\n                    rawEXIF = _rawEXIF;\n                    orientation = that.__getEXIFOrientation(view, IFD0Offset, littleEndian);\n                    thumbnail = that.__getEXIFThumbnail(view, tiffOffset, IFD1Offset, littleEndian, blob);\n                    resolve({ orientation, rawEXIF, thumbnail });\n                }\n                catch (error) {\n                    that._logger.warn(\"Error extracting EXIF data\", error);\n                    resolve({ orientation, rawEXIF, thumbnail });\n                }\n            };\n            reader.onerror = function (error) {\n                that._logger.error(\"Error reading EXIF data\", error);\n                reject(new Error(\"Error reading EXIF data\"));\n            };\n            try {\n                // Pull in _just_ enough to find the APP1 marker + length\n                (blob?.slice ? blob.slice(0, 64 * 1024) : blob).arrayBuffer().then((buf) => {\n                    const view = new DataView(buf);\n                    // scan for 0xFFE1\n                    let offset = 2;\n                    while (offset + 4 < view.byteLength) {\n                        if (view.getUint16(offset) === 0xffe1)\n                            break;\n                        offset += 1;\n                    }\n                    if (offset + 4 >= view.byteLength) {\n                        // no EXIF found in first 4KB, fall back to 64KB\n                        reader.readAsArrayBuffer(blob);\n                    }\n                    else {\n                        offset += 2; // land on length field\n                        const sectionLength = view.getUint16(offset);\n                        const fullEXIFSize = 2 /* marker */ + 2 /* length */ + sectionLength - 2;\n                        // now read exactly that many bytes from the original blob\n                        reader.readAsArrayBuffer(blob.slice(0, fullEXIFSize));\n                    }\n                });\n            }\n            catch (error) {\n                this._logger.error(\"Error reading Blob for EXIF data\", error);\n                reject(new Error(\"Error reading Blob for EXIF data\"));\n            }\n        });\n    }\n    /**\n     * Injects EXIF data into a JPEG Blob.\n     * @param {Blob} blob  - JPEG Blob object\n     * @param {Uint8Array<ArrayBufferLike>} rawEXIF  the APP1 payload (excludes SOI)\n     * @returns {Promise<Blob>}  JPEG Blob with EXIF restored\n     * @static\n     * @async\n     */\n    static async injectBlobExif(blob, rawEXIF) {\n        // If no EXIF at all, nothing to do\n        this._logger.debug(\"Injecting EXIF data into JPEG Blob\");\n        if (!rawEXIF || rawEXIF.byteLength === 0) {\n            this._logger.debug(\"No EXIF data to inject, returning original blob\");\n            return blob;\n        }\n        try {\n            // 1) Modify the Orientation tag in-place via a DataView over the Uint8Array\n            const exifView = new DataView(rawEXIF.buffer, rawEXIF.byteOffset, rawEXIF.byteLength);\n            const { tiffOffset, IFD0Offset, littleEndian } = this.__parseExifMetadata(rawEXIF);\n            // Number of entries in IFD0\n            const entryCount = exifView.getUint16(tiffOffset + IFD0Offset, littleEndian);\n            // Loop each 12-byte directory entry looking for tag 0x0112\n            let ptr = tiffOffset + IFD0Offset + 2;\n            for (let i = 0; i < entryCount; i++, ptr += 12) {\n                if (exifView.getUint16(ptr, littleEndian) === 0x0112) {\n                    // set Orientation  1\n                    exifView.setUint16(ptr + 8, 1, littleEndian);\n                    break;\n                }\n            }\n            // 2) Build a full APP1 segment: 0xFF,0xE1, [length], [rawEXIF]\n            const segLen = rawEXIF.byteLength + 2; // length includes itself\n            const segment = new Uint8Array(rawEXIF.byteLength + 4);\n            segment[0] = 0xff;\n            segment[1] = 0xe1;\n            segment[2] = (segLen >> 8) & 0xff;\n            segment[3] = segLen & 0xff;\n            segment.set(rawEXIF, 4);\n            // 3) Splice SOI + APP1 + rest-of-JPEG\n            const resizedAB = await blob.arrayBuffer();\n            const orig = new Uint8Array(resizedAB);\n            if (orig[0] !== 0xff || orig[1] !== 0xd8) {\n                this._logger.error(\"Input blob is not a JPEG! Cannot inject EXIF data.\");\n                return blob;\n            }\n            const out = new Uint8Array(orig.length + segment.length);\n            // copy SOI (2 bytes)\n            out.set(orig.subarray(0, 2), 0);\n            // insert our APP1\n            out.set(segment, 2);\n            // copy the rest\n            out.set(orig.subarray(2), 2 + segment.length);\n            return new Blob([out], { type: \"image/jpeg\" });\n        }\n        catch (error) {\n            this._logger.error(\"Error injecting EXIF data\", error);\n            return blob; // Return original blob if error occurs\n        }\n    }\n    /**\n     * Calculate the maximum dimensions for an image.\n     * @param {Dimensional} imageData - The image element to resize.\n     * @param {number} maxWH - The maximum width or height.\n     * @returns {{ width: number, height: number }} - The max dimensions for the image.\n     */\n    static calcMaxDimensions(imageData, maxWH) {\n        const { width, height } = imageData;\n        // No limit or image already within bounds\n        if (!maxWH || maxWH <= 0 || (width <= maxWH && height <= maxWH)) {\n            return { width, height };\n        }\n        // Scale dimensions proportionally\n        if (width >= height) {\n            const scaledHeight = (height * maxWH) / width;\n            return { width: maxWH, height: scaledHeight };\n        }\n        else {\n            const scaledWidth = (width * maxWH) / height;\n            return { width: scaledWidth, height: maxWH };\n        }\n    }\n    /**\n     * Transform the canvas based on EXIF orientation.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - The canvas to transform.\n     * @param {number} orientation - The EXIF orientation value.\n     * @returns {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} - The transformed canvas context.\n     * @static\n     */\n    static exifTransformCanvas(canvas, orientation) {\n        const { width: originalWidth, height: originalHeight } = canvas;\n        // prettier-ignore\n        return (() => {\n            if (orientation >= 5 && orientation <= 8) {\n                canvas.width = originalHeight;\n                canvas.height = originalWidth;\n            }\n            const ctx = (canvas instanceof HTMLCanvasElement) ? canvas.getContext(\"2d\") : canvas.getContext(\"2d\");\n            switch (orientation) {\n                case 2:\n                    ctx.translate(originalWidth, 0);\n                    ctx.scale(-1, 1);\n                    break;\n                case 3:\n                    ctx.translate(originalWidth, originalHeight);\n                    ctx.rotate(Math.PI);\n                    break;\n                case 4:\n                    ctx.translate(0, originalHeight);\n                    ctx.scale(1, -1);\n                    break;\n                case 5:\n                    ctx.rotate(0.5 * Math.PI);\n                    ctx.scale(1, -1);\n                    break;\n                case 6:\n                    ctx.rotate(0.5 * Math.PI);\n                    ctx.translate(0, -originalHeight);\n                    break;\n                case 7:\n                    ctx.rotate(0.5 * Math.PI);\n                    ctx.translate(originalWidth, -originalHeight);\n                    ctx.scale(-1, 1);\n                    break;\n                case 8:\n                    ctx.rotate(-0.5 * Math.PI);\n                    ctx.translate(-originalWidth, 0);\n                    break;\n            }\n            return ctx;\n        })();\n    }\n    // --- Utility Methods ---\n    /**\n     * Check if the specified MIME type is natively supported.\n     * @param {string} mime - The MIME type to check.\n     * @returns {boolean} True if the MIME type is supported; otherwise, false.\n     * @static\n     * @scope private\n     * @description This function checks against a predefined list of supported MIME types.\n     * It is used to determine if the browser can handle the image format natively without needing\n     * a plugin or custom decoder.\n     */\n    static _isNativeSupported(mime) {\n        return [\"image/jpeg\", \"image/png\", \"image/webp\", \"image/gif\"].includes(mime);\n    }\n    /**\n     * Checks if the current environment is iOS.\n     * @returns {boolean} - True if the environment is iOS, false otherwise.\n     * @scope private\n     */\n    static _isIOS() {\n        return feature_lib_1.Env.os === \"iOS\";\n    }\n    /**\n     * Normalize the input to a Blob.\n     * @param {ImageInput} input - The input to normalize.\n     * @returns {Promise<Blob>} - The normalized Blob.\n     * @static\n     * @scope private\n     * @throws {Error} If the input type is unsupported.\n     * @description This function handles different input types:\n     * - If the input is a string (URL), it fetches the resource and returns it as a Blob.\n     * - If the input is a File or Blob, it returns it directly.\n     * - If the input type is unsupported, it throws an error.\n     *\n     * This is useful for ensuring that all inputs to the image reader are in a consistent format.\n     */\n    static async _normalizeInput(input) {\n        if (typeof input === \"string\") {\n            const response = await fetch(input);\n            return await response.blob();\n        }\n        else if (input instanceof File || input instanceof Blob) {\n            return input;\n        }\n        else if (input instanceof extendedFile_lib_1.ExtendedFile) {\n            // If input is an instance of ExtendedFile, return its Blob\n            return input.getSource();\n        }\n        else {\n            throw new Error(\"Unsupported input type\");\n        }\n    }\n    /**\n     * Sniff the native resolution of an image file.\n     * @param {File|Blob} file - The image file or blob to inspect.\n     * @returns {Promise<Dimensional>} - The native resolution of the image.\n     * @static\n     * @scope private\n     */\n    static async _sniffNativeResolution(file) {\n        const buffer = await file.slice(0, 512).arrayBuffer();\n        const view = new DataView(buffer);\n        const header = new Uint8Array(buffer);\n        try {\n            // PNG\n            if (header[0] === 0x89 && header[1] === 0x50) {\n                return {\n                    width: view.getUint32(16),\n                    height: view.getUint32(20),\n                };\n            }\n            // GIF\n            if (header[0] === 0x47 && header[1] === 0x49) {\n                return {\n                    width: view.getUint16(6, true),\n                    height: view.getUint16(8, true),\n                };\n            }\n            // WebP\n            if (header[0] === 0x52 && header[1] === 0x49 && header[8] === 0x57) {\n                /**const _vp8x = */ view.getUint8(15);\n                const width = 1 + this.__getDataViewUint24(view, 24);\n                const height = 1 + this.__getDataViewUint24(view, 27);\n                return { width, height };\n            }\n            // JPEG\n            if (header[0] === 0xff && header[1] === 0xd8) {\n                return this.__sniffJPEGResolution(file);\n            }\n        }\n        catch (error) {\n            this._logger.error(\"Error sniffing native resolution\", error);\n            throw error;\n        }\n        throw new Error(\"Unsupported format or corrupt file.\");\n    }\n    /**\n     * Sniff the JPEG resolution from a file or blob.\n     * @param {File|Blob} file - The image file or blob to inspect.\n     * @returns {Promise<Dimensional>} - The resolution of the image.\n     * @static\n     * @scope private\n     */\n    static async __sniffJPEGResolution(file) {\n        const SOF_MARKERS = [0xc0, 0xc2];\n        const MAX_JPEG_SCAN_BYTES = 65536;\n        const reader = file.stream().getReader();\n        let buffer = new Uint8Array();\n        let bytesRead = 0;\n        while (bytesRead < MAX_JPEG_SCAN_BYTES) {\n            const { value, done } = await reader.read();\n            if (done)\n                break;\n            if (!value)\n                continue;\n            // Append the new chunk to the existing buffer\n            const newBuffer = new Uint8Array(buffer.length + value.length);\n            newBuffer.set(buffer);\n            newBuffer.set(value, buffer.length);\n            buffer = newBuffer;\n            bytesRead += value.length;\n            // simplified linear scan for SOF0/2\n            for (let i = 0; i < buffer.length - 1; i++) {\n                // found a marker prefix?\n                if (buffer[i] === 0xff && buffer[i + 1] !== 0xff && buffer[i + 1] !== 0x00) {\n                    const marker = buffer[i + 1];\n                    if (SOF_MARKERS.includes(marker)) {\n                        // need at least 9 bytes from marker: 0xFF, marker, length(2), precision(1), H(2), W(2)\n                        if (i + 8 < buffer.length) {\n                            const height = (buffer[i + 5] << 8) + buffer[i + 6];\n                            const width = (buffer[i + 7] << 8) + buffer[i + 8];\n                            reader.cancel();\n                            return { width, height };\n                        }\n                        // else: SOF header split across chunks, break and read more\n                        break;\n                    }\n                }\n            }\n        }\n        reader.cancel();\n        throw new Error(\"SOF marker not found within first 64KB of JPEG data.\");\n    }\n    // --- Conversions ---\n    /**\n     * Decode a Blob into a canvas using the Image browser's Image class, applying EXIF transformations if necessary.\n     * @param {Blob} blob - The Blob to convert.\n     * @param {ImageLoadOptions} [options] - Options for decoding.\n     * @returns {Promise<ImageDecodeResult>} - A promise that resolves with the canvas, blob and metadata.\n     * @throws {Error} If the decoding process fails.\n     * @static\n     * @scope private\n     * @description This function creates a canvas element, draws the image onto it, and applies any necessary transformations based on EXIF data.\n     */\n    static async _imageDecodeBlob(blob, options) {\n        const { maxWidthOrHeight: maxSize = 4096, preserveHeaders = false } = options || {};\n        const canvasSupport = feature_lib_1.Capabilities.canSupportCanvas();\n        const metadata = await this.getEXIF(blob).catch((error) => {\n            this._logger.error(\"Error getting EXIF data, defaulting to orientation 1:\", error);\n            return { orientation: 1 };\n        });\n        const orientation = metadata.orientation || 1;\n        const fixOrientation = (0, functions_1.is_numeric)(orientation) &&\n            orientation != 1 &&\n            !preserveHeaders && // if we are preserving headers, we do not fix orientation\n            !feature_lib_1.Capabilities.canAutoRotateImages();\n        if (!canvasSupport) {\n            this._logger.warn(\"Canvas support is not available, returning Blob without conversion.\");\n            return {\n                blob,\n                orientation,\n                metadata,\n            };\n        }\n        const img = await this._blobToImage(blob);\n        const { width, height } = this.calcMaxDimensions(img, maxSize);\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        if (orientation != 1) {\n            this._logger.debug(`${fixOrientation ? \"C\" : \"Not c\"}orrecting image with orientation ${orientation}`);\n        }\n        const ctx = fixOrientation ? this.exifTransformCanvas(canvas, orientation) : canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n        if (orientation !== 1)\n            blob = await this._canvasToBlob(canvas, 1);\n        if (metadata && metadata.rawEXIF)\n            blob = await this.injectBlobExif(blob, metadata.rawEXIF);\n        return { canvas, blob, orientation, metadata };\n    }\n    /**\n     * Decode a Blob via an ImageBitmap, applying EXIF transformations if necessary.\n     * @param {Blob} blob - The Blob to convert.\n     * @param {ImageLoadOptions} [options] - Options for decoding.\n     * @returns {Promise<ImageDecodeResult>} - A promise that resolves with the ImageBitmap, blob and metadata.\n     * @throws {Error} If the decoding process fails.\n     * @static\n     * @scope private\n     * @description This function creates an ImageBitmap from the Blob and applies any necessary transformations based on EXIF data.\n     */\n    static async _bitmapDecodeBlob(blob, options) {\n        if (!window.createImageBitmap) {\n            throw new Error(\"createImageBitmap is not supported in this environment.\");\n        }\n        const { maxWidthOrHeight: maxSize = 4096, preserveHeaders = false } = options || {};\n        const canvasSupport = feature_lib_1.Capabilities.canSupportCanvas();\n        const metadata = await this.getEXIF(blob).catch((error) => {\n            this._logger.error(\"Error getting EXIF data, defaulting to orientation 1:\", error);\n            return { orientation: 1 };\n        });\n        const orientation = metadata.orientation || 1;\n        const fixOrientation = (0, functions_1.is_numeric)(orientation) &&\n            orientation != 1 &&\n            !preserveHeaders && // if we are preserving headers, we do not fix orientation\n            !feature_lib_1.Capabilities.canAutoRotateImages();\n        if (!canvasSupport) {\n            this._logger.warn(\"Canvas support is not available, returning Blob without conversion.\");\n            return {\n                blob,\n                orientation,\n                metadata,\n            };\n        }\n        const bitmap = await createImageBitmap(blob, {\n            imageOrientation: fixOrientation ? \"none\" : \"from-image\",\n        });\n        const { width, height } = this.calcMaxDimensions(bitmap, maxSize);\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = fixOrientation ? this.exifTransformCanvas(canvas, orientation) : canvas.getContext(\"2d\");\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);\n        if (orientation !== 1)\n            blob = await this._canvasToBlob(canvas, 1);\n        if (metadata && metadata.rawEXIF)\n            blob = await this.injectBlobExif(blob, metadata.rawEXIF);\n        return { canvas, blob, orientation, metadata };\n    }\n    /**\n     * Convert a Blob to an Image element.\n     * @param {Blob} blob - The Blob to convert.\n     * @returns {Promise<HTMLImageElement>} - A promise that resolves with the Image element.\n     * @static\n     * @scope private\n     * @description This function creates a temporary URL for the Blob, loads it into an Image element,\n     * and resolves the promise with the Image once it has loaded. It also revokes the URL\n     * to free up memory.\n     */\n    static _blobToImage(blob) {\n        return new Promise((resolve, reject) => {\n            const url = URL.createObjectURL(blob);\n            const img = new Image();\n            img.onload = () => {\n                URL.revokeObjectURL(url);\n                resolve(img);\n            };\n            img.onerror = reject;\n            img.src = url;\n        });\n    }\n    /**\n     * Convert a Canvas element to a Blob.\n     * @param {HTMLCanvasElement} canvas - The canvas to convert.\n     * @param {number} [quality=0.9] - The quality of the image (0 to 1).\n     * @returns {Promise<Blob>} - A promise that\n     * @scope private\n     */\n    static _canvasToBlob(canvas, quality) {\n        return new Promise((resolve, reject) => {\n            try {\n                canvas.toBlob((blob) => {\n                    if (blob) {\n                        resolve(blob);\n                    }\n                    else {\n                        reject(new Error(\"Failed to convert canvas to Blob\"));\n                    }\n                }, \"image/jpeg\", quality);\n            }\n            catch (e) {\n                reject(new Error(`Canvas to Blob conversion failed: ${e.message}`));\n            }\n        });\n    }\n    /**\n     * Decodes an image using a specified plugin.\n     * @param {ImageDecoderPluginFn} decoder - The decoding function to use.\n     * @param {Blob} blob - The image Blob to decode.\n     * @param {ImageLoadOptions} [options] - Options for decoding.\n     * @returns {Promise<ImageDecodeResult>} - The decoded image data.\n     * @static\n     * @scope private\n     * @throws {Error} If the decoding process fails.\n     */\n    static async _decodePlugin(decoder, blob, options) {\n        const mimeType = blob.type;\n        try {\n            const result = await decoder(blob, options);\n            this._logger.debug(`Decoding result for MIME type: ${mimeType}`, result);\n            return {\n                canvas: result.canvas,\n                blob: result.blob,\n                orientation: result.orientation || (result.metadata && result.metadata.orientation) || 1,\n                metadata: result.metadata || {},\n            };\n        }\n        catch (error) {\n            this._logger.error(`Plugin decoding failed for MIME type: ${mimeType}`, error);\n            throw new Error(`Plugin decoding failed for MIME type: ${mimeType}`);\n        }\n    }\n    /**\n     * Conditionally decodes an image using native canvas or in-memory capabilities.\n     * @param {Blob} blob - The Blob to decode.\n     * @param {ImageLoadOptions} [options] - Options for decoding.\n     * @returns {Promise<ImageDecodeResult>} - The decoded image data.\n     * @static\n     * @scope private\n     * @throws {Error} If the image format is unsupported/corrupt or insufficient resources are available.\n     */\n    static async _maybeDecodeNative(blob, options) {\n        let DECODERS;\n        (function (DECODERS) {\n            DECODERS[DECODERS[\"BITMAP\"] = 1] = \"BITMAP\";\n            DECODERS[DECODERS[\"IMAGE\"] = 2] = \"IMAGE\";\n            DECODERS[DECODERS[\"PLUGIN\"] = 3] = \"PLUGIN\";\n        })(DECODERS || (DECODERS = {}));\n        const mime = blob.type, decoderOrder = (await this.__shouldUseNativeDecoder(blob))\n            ? [DECODERS.BITMAP, DECODERS.IMAGE, DECODERS.PLUGIN]\n            : [DECODERS.PLUGIN, DECODERS.BITMAP, DECODERS.IMAGE];\n        let error;\n        for (const stage of decoderOrder) {\n            switch (stage) {\n                // ImageBitmap Decoding\n                case DECODERS.BITMAP: {\n                    try {\n                        this._logger.debug(`Attempting to decode image with ImageBitmap for MIME type: ${mime}`);\n                        const result = await this._bitmapDecodeBlob(blob, options);\n                        if (result)\n                            return result;\n                    }\n                    catch (e) {\n                        this._logger.error(\"Error decoding image with ImageBitmap:\", e);\n                        error = new Error(\"Bad format, or insufficient resources available to decode image via ImageBitmap.\");\n                    }\n                    break;\n                }\n                // Native Image Decoding\n                case DECODERS.IMAGE: {\n                    try {\n                        this._logger.debug(`Attempting to decode image with native Image for MIME type: ${mime}`);\n                        const result = await this._imageDecodeBlob(blob, options);\n                        if (result)\n                            return result;\n                    }\n                    catch (e) {\n                        this._logger.error(\"Error decoding image with native canvas:\", e);\n                        error = new Error(\"Bad format, or insufficient resources available to decode image via native Image.\");\n                    }\n                    break;\n                }\n                // Plugin-based Decoding\n                case DECODERS.PLUGIN: {\n                    const inMemoryDecoder = this._plugins.find((p) => p.mimeType === \"image/*\");\n                    if (inMemoryDecoder) {\n                        try {\n                            this._logger.debug(`Using in-memory plugin for large file MIME type: ${mime}`);\n                            const result = await inMemoryDecoder.decoderFn(blob, options);\n                            return {\n                                canvas: result.canvas,\n                                blob: result.blob,\n                                orientation: result.orientation || (result.metadata && result.metadata.orientation) || 1,\n                                metadata: result.metadata || {},\n                            };\n                        }\n                        catch (e) {\n                            this._logger.error(\"Error decoding image with in-memory plugin:\", e);\n                            error = new Error(\"Bad format, or insufficient resources available to decode image via in-memory plugin.\");\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        // Step 4: If we reach here, it means both attempts failed\n        if (error)\n            throw error;\n        throw new Error(\"Unsupported image format or corrupt file.\");\n    }\n    /**\n     * Determine if the native decoder should be used based on image properties.\n     * @param {Blob} blob - The image Blob to evaluate.\n     * @returns {Promise<boolean>} - True if the native decoder should be used; otherwise, false.\n     * @static\n     * @scope private\n     */\n    static async __shouldUseNativeDecoder(blob) {\n        if (!this._isNativeSupported(blob.type)) {\n            return false;\n        }\n        let width = 0, height = 0;\n        try {\n            ({ width, height } = await this._sniffNativeResolution(blob));\n        }\n        catch (e) {\n            this._logger.error(\"Error sniffing native resolution:\", e);\n        }\n        if (width > 0 && height > 0) {\n            const MIN_DENSITY = 500 * 1024, MIN_IOS_AREA = 4096 ** 2, mp = (width * height) / 1024000, bytesPerMP = blob.size / mp;\n            // Disable until vips can work with a credentialless COEP policy?\n            return this._isIOS() ? width * height <= MIN_IOS_AREA : bytesPerMP < MIN_DENSITY;\n        }\n        return false; // unknown size, assume not native\n    }\n    // --- EXIF ---\n    /**\n     * Get a 24-bit unsigned integer from a DataView.\n     * @param {DataView} view - The DataView to read from.\n     * @param {number} offset - The byte offset to start reading.\n     * @returns {number} - The 24-bit unsigned integer.\n     * @static\n     * @scope private\n     */\n    static __getDataViewUint24(view, offset) {\n        return view.getUint8(offset) | (view.getUint8(offset + 1) << 8) | (view.getUint8(offset + 2) << 16);\n    }\n    /**\n     * Get the raw EXIF data from a DataView.\n     * @param {DataView} view - The DataView of the image data.\n     * @returns {ImageRawEXIFData} - The raw EXIF data and offsets, or null if not found.\n     * @static\n     * @scope private\n     */\n    static __getRawEXIFData(view) {\n        let offset = 2; // skip past SOI (0xFFD8)\n        const length = view.byteLength;\n        while (offset + 4 < length) {\n            const marker = view.getUint16(offset);\n            // APP1?  (0xFFE1)\n            if (marker === 0xffe1) {\n                offset += 2; // move into the length field\n                const sectionLength = view.getUint16(offset);\n                if (offset + sectionLength > length)\n                    break; // malformed\n                offset += 2; // now at start of payload\n                // Check for \"Exif\\0\\0\" signature\n                if (view.getUint32(offset) !== 0x45786966 /* \"Exif\" */) {\n                    this._logger.debug(\"No EXIF header signature found\");\n                    break;\n                }\n                // include the 0xFFE1 marker (2 bytes) + length field (2 bytes) + payload\n                const app1Start = offset - 4; // back up past marker+length\n                const app1Total = sectionLength + 2; // length includes payload+2 length bytes\n                const rawEXIF = new Uint8Array(view.buffer, app1Start, app1Total);\n                // TIFF header lives 6 bytes in (\"Exif\\0\\0\" = 6 bytes)\n                const tiffOffset = offset + 6;\n                // Read byte-order marker (II = 0x4949  little-endian)\n                const littleEndian = view.getUint16(tiffOffset, false) === 0x4949;\n                // Offset to 0th IFD is a 32-bit uint at tiffOffset+4\n                const firstIFD = view.getUint32(tiffOffset + 4, littleEndian);\n                const IFD0Offset = tiffOffset + firstIFD;\n                // Compute IFD1 pointer for thumbnail (if present)\n                const entryCount = view.getUint16(IFD0Offset, littleEndian);\n                const nextIFDPtr = IFD0Offset + 2 + entryCount * 12;\n                let IFD1Offset = null;\n                if (nextIFDPtr + 4 <= length) {\n                    const ptr = view.getUint32(nextIFDPtr, littleEndian);\n                    // only accept a nonzero pointer that actually points inside the data:\n                    if (ptr !== 0) {\n                        const validPtr = tiffOffset + ptr;\n                        // ensure there's at least room for the 2byte entry count (or just that it's < length)\n                        if (validPtr + 2 <= length) {\n                            IFD1Offset = validPtr;\n                        }\n                    }\n                }\n                return { rawEXIF, tiffOffset, littleEndian, IFD0Offset, IFD1Offset };\n            }\n            // Not APP1skip this segment\n            if ((marker & 0xff00) !== 0xff00) {\n                break; // invalid marker, bail out\n            }\n            offset += 2; // skip marker\n            const skipLen = view.getUint16(offset);\n            offset += skipLen; // jump to next marker\n        }\n        return null; // no EXIF APP1 found\n    }\n    /**\n     * Extract EXIF orientation from the image data.\n     * @param {DataView} view - The DataView of the image data.\n     * @param {number} offset - The offset to the TIFF header.\n     * @param {boolean} littleEndian - Whether the data is in little-endian format.\n     * @returns {number} - The EXIF orientation value (1-8).\n     * @static\n     * @scope private\n     */\n    static __getEXIFOrientation(view, offset, littleEndian) {\n        try {\n            const numEntries = view.getUint16(offset, littleEndian);\n            offset += 2;\n            for (let i = 0; i < numEntries; i++) {\n                const tagOffset = offset + i * 12;\n                const tag = view.getUint16(tagOffset, littleEndian);\n                if (tag === 0x0112) {\n                    return view.getUint16(tagOffset + 8, littleEndian);\n                }\n            }\n        }\n        catch (error) {\n            this._logger.warn(\"Error extracting EXIF orientation\", error);\n            // If we can't read the orientation, default to 1 (normal orientation)\n            return 1;\n        }\n        return 1; // default orientation\n    }\n    /**\n     * Extract EXIF thumbnail from the image data.\n     * @param {DataView} view - The DataView of the image data.\n     * @param {number} tiffOffset - The offset to the TIFF header.\n     * @param {number} IFD1Offset - The offset to the first IFD (Image File Directory).\n     * @param {boolean} littleEndian - Whether the data is in little-endian format.\n     * @param {Blob|File} blob - The original Blob or File of the image.\n     * @returns {Blob|undefined} - The EXIF thumbnail as a Blob, or undefined if not found.\n     * @static\n     * @scope private\n     */\n    static __getEXIFThumbnail(view, tiffOffset, IFD1Offset, littleEndian, blob) {\n        if (!IFD1Offset)\n            return undefined;\n        try {\n            const numTags = view.getUint16(tiffOffset + IFD1Offset, littleEndian);\n            let thumbOffset = null;\n            let thumbLength = null;\n            for (let i = 0; i < numTags; i++) {\n                const tagOffset = tiffOffset + IFD1Offset + 2 + i * 12;\n                const tag = view.getUint16(tagOffset, littleEndian);\n                const valueOffset = tagOffset + 8;\n                if (tag === 0x0201) {\n                    thumbOffset = view.getUint32(valueOffset, littleEndian);\n                }\n                if (tag === 0x0202) {\n                    thumbLength = view.getUint32(valueOffset, littleEndian);\n                }\n            }\n            if (thumbOffset && thumbLength) {\n                return blob.slice(tiffOffset + thumbOffset, tiffOffset + thumbOffset + thumbLength, \"image/jpeg\");\n            }\n        }\n        catch (_) {\n            // Graceful failure\n            return undefined;\n        }\n        return undefined;\n    }\n    /**\n     * Reconstruct basic EXIF metadata from rawEXIF bytes alone.\n     * @param {Uint8Array<ArrayBufferLike>} rawEXIF - The APP1 payload, including the 6-byte \"Exif\\0\\0\" header and TIFF header.\n     * @returns {ImageEXIFMetadata}\n     * @static\n     * @scope private\n     */\n    static __parseExifMetadata(rawEXIF) {\n        // DataView over the same bytes\n        const view = new DataView(rawEXIF.buffer, rawEXIF.byteOffset, rawEXIF.byteLength);\n        // skip \"Exif\\0\\0\" if present\n        const hasPreamble = rawEXIF.byteLength > 6 && [0x45, 0x78, 0x69, 0x66, 0x00, 0x00].every((b, i) => view.getUint8(i) === b);\n        const tiffOffset = hasPreamble ? 6 : 0;\n        // byte-order\n        const bom = view.getUint16(tiffOffset, false);\n        const littleEndian = bom === 0x4949;\n        if (bom !== 0x4949 && bom !== 0x4d4d) {\n            throw new Error(\"Bad TIFF BOM\");\n        }\n        // TIFF magic\n        if (view.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n            throw new Error(\"Bad TIFF magic\");\n        }\n        // IFD0 offset\n        const IFD0Offset = view.getUint32(tiffOffset + 4, littleEndian);\n        // IFD1 pointer\n        const numEntries = view.getUint16(tiffOffset + IFD0Offset, littleEndian);\n        const nextPtrOff = tiffOffset + IFD0Offset + 2 + numEntries * 12;\n        let IFD1Offset = null;\n        if (nextPtrOff + 4 <= view.byteLength) {\n            IFD1Offset = view.getUint32(nextPtrOff, littleEndian);\n        }\n        return { littleEndian, tiffOffset, IFD0Offset, IFD1Offset };\n    }\n}\nexports.ImageReader = ImageReader;\n/** Plugin matrix for mime-based image decoders.\n * @type {Array<{ mimeType: string, decoderFn: ImageDecoderPluginFn }>}\n * @static\n * @property {string} mimeType - The MIME type of the image format\n * @property {ImageDecoderPluginFn} decoderFn - The function to decode the image format\n */\nImageReader._plugins = [];\n/**\n * Logger instance for logging debug messages.\n * @type {Logger}\n * @static\n * @scope private\n */\nImageReader._logger = console_logger_1.Logger.getInstance();\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageUploader = void 0;\n/// <reference types=\"jquery\" />\nconst console_logger_1 = __importDefault(require(\"../console.logger\"));\nconst functions_1 = require(\"../utils/functions\");\nconst defaults_data_1 = require(\"../data/uploader/defaults.data\");\nconst uploadController_lib_1 = require(\"./uploadController.lib\");\n/**\n * ImageUploader class\n * @class\n * @description Handles image uploading functionality, including drag-and-drop support and file input management.\n */\nclass ImageUploader {\n    /**\n     * Constructor for ImageUploader\n     * @param {JQuery<HTMLElement>} $targetElement - The jQuery element to attach the uploader to.\n     * @param {ImageUploaderSettings} options - Configuration settings for the uploader.\n     * @throws {Error} If the upload URL is invalid or if required options are missing.\n     * @scope public\n     * @constructor\n     */\n    constructor($targetElement, options) {\n        if (!(0, functions_1.is_uri)(options.uploadUrl || \"\"))\n            throw new Error(\"Invalid upload URL provided in options.\");\n        if (options.resize)\n            options.resize = (0, functions_1.merge_options)(defaults_data_1.RESIZE_DEFAULTS, options.resize, [\"width\", \"height\"]);\n        if (options.thumbnails)\n            options.thumbnails = (0, functions_1.merge_options)(defaults_data_1.THUMB_SIZE_DEFAULTS, options.thumbnails);\n        if (options.transportMode && options.transportMode === \"S3\") {\n            options.s3Options = (0, functions_1.merge_options)(defaults_data_1.S3_OPTIONS_DEFAULTS, options.s3Options || {});\n        }\n        Object.defineProperty(options, \"targetElement\", {\n            value: $targetElement,\n            writable: false,\n            enumerable: true,\n            configurable: false,\n        });\n        this.$targetElement = $targetElement;\n        this.settings = Object.assign({}, defaults_data_1.defaultOptions, options);\n        this.uploader = new uploadController_lib_1.UploadController(this.settings);\n        this.logger = console_logger_1.default.getInstance();\n    }\n    /**\n     * Initializes the uploader by setting up event listeners and creating necessary DOM elements.\n     * @scope public\n     */\n    initialize() {\n        // Initialize file input element\n        this.initializeFileInput();\n        // Handle drag-and-drop functionality if dropElement is provided\n        if (this.settings.dropElement) {\n            this.initializeDropZone();\n        }\n        // initialize the uploader\n        this.uploader.initialize();\n    }\n    /**\n     * Gets the instance of the target element\n     * @returns {JQuery<HTMLElement>}\n     * @scope public\n     */\n    getInstance() {\n        return this.$targetElement;\n    }\n    /**\n     * Gets a specific option from the settings\n     * @param {keyof ImageUploaderSettings} option\n     * @returns {ImageUploaderSettings[T]}\n     * @scope public\n     */\n    getOption(option) {\n        return this.settings[option];\n    }\n    /**\n     * Updates a specific option in the settings\n     * @param {keyof ImageUploaderSettings} option\n     * @param {any} value\n     * @scope public\n     */\n    setOption(option, value) {\n        if (option in this.settings) {\n            this.settings[option] = value;\n        }\n        this.logger.debug(`Option ${option} has been updated to`, value);\n    }\n    /**\n     * Cancels an ongoing upload process.\n     * @scope public\n     */\n    cancel() {\n        // Clone of reset\n        this.reset();\n    }\n    /**\n     * Destroys the uploader instance\n     * @scope public\n     */\n    destroy() {\n        const $browseButton = $(this.settings.browseButton || \"\");\n        // Reset the plugin state\n        this.reset();\n        try {\n            // Remove all event listeners added by the plugin\n            $browseButton?.off(\".uploader\");\n            this.$targetElement?.off(\".uploader\");\n            $(document).off(\".uploader\");\n            if (this.$fileInput) {\n                this.$fileInput?.off();\n                this.$fileInput?.remove();\n                this.$fileInput = undefined;\n            }\n            if (this.$dropZone) {\n                this.$dropZone?.off(\".uploader\");\n            }\n            // Clear any plugin-related data stored on the element\n            this.$targetElement?.removeData(\"imageUploader\");\n        }\n        catch (error) {\n            this.logger.debug(\"Error during destroy:\", error);\n            if (this.$fileInput && this.$fileInput?.length) {\n                this.$fileInput?.remove();\n            }\n        }\n        // Reset performance monitor\n        // Destroy uploader instance\n        this.uploader.destroy();\n        // Log destruction for debugging\n        this.logger.debug(\"imageUploader has been destroyed\");\n    }\n    /**\n     * Resets the uploader state\n     * @scope public\n     */\n    reset() {\n        try {\n            // Clear file input\n            if (this.$fileInput) {\n                this.$fileInput?.val(\"\");\n            }\n            // Remove any progress indicators or error messages\n            if (this.$dropZone) {\n                this.$dropZone?.removeClass(\"active\");\n            }\n        }\n        catch (error) {\n            this.logger.error(\"Error during reset:\", error);\n        }\n        // Reset the uploader state\n        this.uploader.reset();\n        this.logger.debug(\"Uploader has been reset\");\n    }\n    /**\n     * Initializes the file input element\n     * @returns {JQuery<HTMLInputElement>}\n     * @scope private\n     */\n    initializeFileInput() {\n        if (this._validateInput(this.$fileInput, {\n            type: \"file\",\n            id: \"file-upload-input\",\n            multiple: \"multiple\",\n            tagName: \"INPUT\",\n        })) {\n            return this.$fileInput;\n        }\n        // Create file input element\n        const that = this;\n        this.$fileInput = $(\"<input>\", {\n            type: \"file\",\n            id: \"file-upload-input\",\n            multiple: true,\n        });\n        $(document).on(\"mimeType.uploader\", function (_e, acceptedExts) {\n            that.logger.debug(\"mimeType.uploader event triggered with accepted extensions:\", acceptedExts);\n            that.$fileInput.attr(\"accept\", acceptedExts);\n        });\n        // Append file input to the target element\n        if (this.settings.browseButton && $(this.settings.browseButton).length) {\n            const $browseButton = $(this.settings.browseButton);\n            $browseButton.on(\"click.uploader\", function (e) {\n                if ($(e.target).is($browseButton)) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    that.$fileInput.trigger(\"click.uploader\");\n                }\n            });\n            this.$fileInput.css({ display: \"none\" });\n        }\n        $(\"BODY\").append(this.$fileInput);\n        // Handle file selection\n        this.$fileInput.on(\"change\", (e) => {\n            that.logger.debug(\"change event\", Date.now());\n            const $inputElement = e.target;\n            const files = $inputElement.files;\n            that.uploader.filesAdded(files || []);\n        });\n        return this.$fileInput;\n    }\n    /**\n     * Initializes the drop zone for drag-and-drop functionality\n     * @returns {JQuery<HTMLElement> | undefined}\n     * @scope private\n     */\n    initializeDropZone() {\n        const that = this;\n        if (this.settings.dropElement) {\n            if (this._validateInput(this.$dropZone)) {\n                return this.$dropZone;\n            }\n            // Create drop zone element\n            this.$dropZone = $(this.settings.dropElement);\n            if (this.$dropZone.length && this.settings.dragDropEnabled) {\n                if (!this.$fileInput) {\n                    this.initializeFileInput();\n                }\n                // Add click event to drop zone to trigger file input click\n                this.$dropZone.on(\"click.uploader\", function (e) {\n                    if (that.$dropZone && $(e.target).is(that.$dropZone)) {\n                        e.stopPropagation();\n                        that.$fileInput.trigger(\"click.uploader\");\n                    }\n                });\n                // Drag and drop event listeners\n                this.$dropZone.on(\"dragover.uploader\", (e) => {\n                    e.preventDefault();\n                    this.$dropZone.addClass(\"active\");\n                });\n                this.$dropZone.on(\"dragleave.uploader\", () => {\n                    this.$dropZone.removeClass(\"active\");\n                });\n                this.$dropZone.on(\"drop.uploader\", (e) => {\n                    e.preventDefault();\n                    this.$dropZone.removeClass(\"active\");\n                    const originalEvent = e.originalEvent;\n                    const files = originalEvent.dataTransfer?.files || null;\n                    this.uploader.filesAdded(files || []);\n                });\n            }\n        }\n        return this.$dropZone;\n    }\n    /**\n     * Validates the input element\n     * @param {JQuery | undefined} input - The input element to validate\n     * @param {Record<string, any>} [props] - Expected properties to validate against\n     * @returns {boolean} - True if valid, false otherwise\n     */\n    _validateInput(input, props) {\n        if (!input || !(input instanceof $) || !input.length) {\n            return false;\n        }\n        if (props) {\n            for (const prop in props) {\n                if (Object.prototype.hasOwnProperty.call(props, prop) &&\n                    input.attr(prop) !== props[prop] &&\n                    input.prop(prop) !== props[prop]) {\n                    this.logger.debug(`Input element does not have the expected property: ${prop}`);\n                    this.logger.debug(`Expected: ${props[prop]}, Found: ${input.attr(prop) || input.prop(prop)}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\nexports.ImageUploader = ImageUploader;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.imageUploader = imageUploader;\n/// <reference types=\"jquery\" />\nconst console_logger_1 = __importDefault(require(\"./console.logger\"));\nconst imageUploader_lib_1 = require(\"./libs/imageUploader.lib\");\n// Logger initialization\nconst logger = console_logger_1.default.getInstance();\nlogger.debug(\"Logger is already loaded and ready to use\");\n/**\n * jQuery ImageUploader plugin\n * @function\n * @param {ImageUploaderSettings | string} methodOrOptions - Configuration settings for the uploader or a method name\n * @param {...any[]} [args] - Additional arguments for the method\n * @returns {JQuery | any}\n * @throws {Error} if the uploader instance is not initialized correctly.\n */\nfunction imageUploader(methodOrOptions, ...args) {\n    // Handle method calls (getters/setters)\n    if (typeof methodOrOptions === \"string\") {\n        const $el = $(this[0]); // Get first element only\n        const instance = $el.data(\"eso-uploader\");\n        if (!instance) {\n            throw new Error(\"Cannot set/get options on uninitialized uploader instance.\");\n        }\n        const method = instance[methodOrOptions];\n        if (typeof method === \"function\") {\n            const result = method.apply(instance, args);\n            if (typeof result === \"undefined\")\n                return this; // For chaining\n            return result; // Return the result of the method call\n        }\n        throw new Error(`Method '${methodOrOptions}' not found on uploader instance.`);\n    }\n    return this.each((_, el) => {\n        const $el = $(el);\n        let instance = $el.data(\"eso-uploader\");\n        if (!instance) {\n            // initialize uploader instance\n            instance = new imageUploader_lib_1.ImageUploader($el, methodOrOptions || {});\n            instance.initialize();\n            $el.data(\"eso-uploader\", instance);\n        }\n        else {\n            // recreate uploader instance with new options\n            instance.destroy();\n            $el.removeData(\"eso-uploader\");\n            instance = new imageUploader_lib_1.ImageUploader($el, methodOrOptions || {});\n            instance.initialize();\n            $el.data(\"eso-uploader\", instance);\n        }\n    });\n}\n(function ($) {\n    \"use strict\";\n    $.fn.imageUploader = imageUploader;\n})($);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.oses = exports.engines = exports.browsers = void 0;\n/* eslint-disable no-useless-escape */\nconst maps_data_1 = require(\"./maps.data\");\nconst mapper_lib_1 = require(\"../../libs/features/mapper.lib\");\nconst common_data_1 = require(\"./common.data\");\n/**\n * Regular expressions for browser detection\n * @type { UAParserRegexList }\n */\nexports.browsers = [\n    [\n        // Presto based\n        /(opera\\smini)\\/([\\w\\.-]+)/i, // Opera Mini\n        /(opera\\s[mobiletab]+).+version\\/([\\w\\.-]+)/i, // Opera Mobi/Tablet\n        /(opera).+version\\/([\\w\\.]+)/i, // Opera > 9.80\n        /(opera)[\\/\\s]+([\\w\\.]+)/i, // Opera < 9.80\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /\\s(opr)\\/([\\w\\.]+)/i, // Opera Webkit\n    ],\n    [[common_data_1.NAME, \"Opera\"], common_data_1.VERSION],\n    [\n        // Mixed\n        /(kindle)\\/([\\w\\.]+)/i, // Kindle\n        /(lunascape|maxthon|netfront|jasmine|blazer)[\\/\\s]?([\\w\\.]+)*/i,\n        // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n        // Trident based\n        /(avant\\s|iemobile|slim|baidu)(?:browser)?[\\/\\s]?([\\w\\.]*)/i,\n        // Avant/IEMobile/SlimBrowser/Baidu\n        /(?:ms|\\()(ie)\\s([\\w\\.]+)/i, // Internet Explorer\n        // Webkit/KHTML based\n        /(rekonq)\\/([\\w\\.]+)*/i, // Rekonq\n        /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi)\\/([\\w\\.-]+)/i,\n        // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(trident).+rv[:\\s]([\\w\\.]+).+like\\sgecko/i, // IE11\n    ],\n    [[common_data_1.NAME, \"IE\"], common_data_1.VERSION],\n    [\n        /(edge)\\/((\\d+)?[\\w\\.]+)/i, // Microsoft Edge\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(yabrowser)\\/([\\w\\.]+)/i, // Yandex\n    ],\n    [[common_data_1.NAME, \"Yandex\"], common_data_1.VERSION],\n    [\n        /(comodo_dragon)\\/([\\w\\.]+)/i, // Comodo Dragon\n    ],\n    [[common_data_1.NAME, /_/g, \" \"], common_data_1.VERSION],\n    [\n        /(chrome|omniweb|arora|[tizenoka]{5}\\s?browser)\\/v?([\\w\\.]+)/i,\n        // Chrome/OmniWeb/Arora/Tizen/Nokia\n        /(uc\\s?browser|qqbrowser)[\\/\\s]?([\\w\\.]+)/i,\n        // UCBrowser/QQBrowser\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(dolfin)\\/([\\w\\.]+)/i, // Dolphin\n    ],\n    [[common_data_1.NAME, \"Dolphin\"], common_data_1.VERSION],\n    [\n        /((?:android.+)crmo|crios)\\/([\\w\\.]+)/i, // Chrome for Android/iOS\n    ],\n    [[common_data_1.NAME, \"Chrome\"], common_data_1.VERSION],\n    [\n        /XiaoMi\\/MiuiBrowser\\/([\\w\\.]+)/i, // MIUI Browser\n    ],\n    [common_data_1.VERSION, [common_data_1.NAME, \"MIUI Browser\"]],\n    [\n        /android.+version\\/([\\w\\.]+)\\s+(?:mobile\\s?safari|safari)/i, // Android Browser\n    ],\n    [common_data_1.VERSION, [common_data_1.NAME, \"Android Browser\"]],\n    [\n        /FBAV\\/([\\w\\.]+);/i, // Facebook App for iOS\n    ],\n    [common_data_1.VERSION, [common_data_1.NAME, \"Facebook\"]],\n    [\n        /version\\/([\\w\\.]+).+?mobile\\/\\w+\\s(safari)/i, // Mobile Safari\n    ],\n    [common_data_1.VERSION, [common_data_1.NAME, \"Mobile Safari\"]],\n    [\n        /version\\/([\\w\\.]+).+?(mobile\\s?safari|safari)/i, // Safari & Safari Mobile\n    ],\n    [common_data_1.VERSION, common_data_1.NAME],\n    [\n        /webkit.+?(mobile\\s?safari|safari)(\\/[\\w\\.]+)/i, // Safari < 3.0\n    ],\n    [common_data_1.NAME, [common_data_1.VERSION, mapper_lib_1.mapper.str, maps_data_1.maps.browser.oldsafari.version]],\n    [\n        /(konqueror)\\/([\\w\\.]+)/i, // Konqueror\n        /(webkit|khtml)\\/([\\w\\.]+)/i,\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        // Gecko based\n        /(navigator|netscape)\\/([\\w\\.-]+)/i, // Netscape\n    ],\n    [[common_data_1.NAME, \"Netscape\"], common_data_1.VERSION],\n    [\n        /(swiftfox)/i, // Swiftfox\n        /(icedragon|iceweasel|camino|chimera|fennec|maemo\\sbrowser|minimo|conkeror)[\\/\\s]?([\\w\\.\\+]+)/i,\n        // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror\n        /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\\/([\\w\\.-]+)/i,\n        // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n        /(mozilla)\\/([\\w\\.]+).+rv\\:.+gecko\\/\\d+/i, // Mozilla\n        // Other\n        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf)[\\/\\s]?([\\w\\.]+)/i,\n        // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf\n        /(links)\\s\\(([\\w\\.]+)/i, // Links\n        /(gobrowser)\\/?([\\w\\.]+)*/i, // GoBrowser\n        /(ice\\s?browser)\\/v?([\\w\\._]+)/i, // ICE Browser\n        /(mosaic)[\\/\\s]([\\w\\.]+)/i, // Mosaic\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n];\n/**\n * Regular expressions for engine detection\n * @type {UAParserRegexList}\n */\nexports.engines = [\n    [\n        /windows.+\\sedge\\/([\\w\\.]+)/i, // EdgeHTML\n    ],\n    [common_data_1.VERSION, [common_data_1.NAME, \"EdgeHTML\"]],\n    [\n        /(presto)\\/([\\w\\.]+)/i, // Presto\n        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\\/([\\w\\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m\n        /(khtml|tasman|links)[\\/\\s]\\(?([\\w\\.]+)/i, // KHTML/Tasman/Links\n        /(icab)[\\/\\s]([23]\\.[\\d\\.]+)/i, // iCab\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /rv\\:([\\w\\.]+).*(gecko)/i, // Gecko\n    ],\n    [common_data_1.VERSION, common_data_1.NAME],\n];\n/**\n * Regular expressions for OS detection\n * @type {UAParserRegexList}\n */\nexports.oses = [\n    [\n        // Windows based\n        /microsoft\\s(windows)\\s(vista|xp)/i, // Windows (iTunes)\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(windows)\\snt\\s6\\.2;\\s(arm)/i, // Windows RT\n        /(windows\\sphone(?:\\sos)*|windows\\smobile|windows)[\\s\\/]?([ntce\\d\\.\\s]+\\w)/i,\n    ],\n    [common_data_1.NAME, [common_data_1.VERSION, mapper_lib_1.mapper.str, maps_data_1.maps.os.windows.version]],\n    [/(win(?=3|9|n)|win\\s9x\\s)([nt\\d\\.]+)/i],\n    [\n        [common_data_1.NAME, \"Windows\"],\n        [common_data_1.VERSION, mapper_lib_1.mapper.str, maps_data_1.maps.os.windows.version],\n    ],\n    [\n        // Mobile/Embedded OS\n        /\\((bb)(10);/i, // BlackBerry 10\n    ],\n    [[common_data_1.NAME, \"BlackBerry\"], common_data_1.VERSION],\n    [\n        /(blackberry)\\w*\\/?([\\w\\.]+)*/i, // Blackberry\n        /(tizen)[\\/\\s]([\\w\\.]+)/i, // Tizen\n        /(android|webos|palm\\os|qnx|bada|rim\\stablet\\sos|meego|contiki)[\\/\\s-]?([\\w\\.]+)*/i,\n        // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki\n        /linux;.+(sailfish);/i, // Sailfish OS\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(symbian\\s?os|symbos|s60(?=;))[\\/\\s-]?([\\w\\.]+)*/i, // Symbian\n    ],\n    [[common_data_1.NAME, \"Symbian\"], common_data_1.VERSION],\n    [\n        /\\((series40);/i, // Series 40\n    ],\n    [common_data_1.NAME],\n    [\n        /mozilla.+\\(mobile;.+gecko.+firefox/i, // Firefox OS\n    ],\n    [[common_data_1.NAME, \"Firefox OS\"], common_data_1.VERSION],\n    [\n        // Console\n        /(nintendo|playstation)\\s([wids3portablevu]+)/i, // Nintendo/Playstation\n        // GNU/Linux based\n        /(mint)[\\/\\s\\(]?(\\w+)*/i, // Mint\n        /(mageia|vectorlinux)[;\\s]/i, // Mageia/VectorLinux\n        /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\\/\\s-]?([\\w\\.-]+)*/i,\n        // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware\n        // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus\n        /(hurd|linux)\\s?([\\w\\.]+)*/i, // Hurd/Linux\n        /(gnu)\\s?([\\w\\.]+)*/i, // GNU\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(cros)\\s[\\w]+\\s([\\w\\.]+\\w)/i, // Chromium OS\n    ],\n    [[common_data_1.NAME, \"Chromium OS\"], common_data_1.VERSION],\n    [\n        // Solaris\n        /(sunos)\\s?([\\w\\.]+\\d)*/i, // Solaris\n    ],\n    [[common_data_1.NAME, \"Solaris\"], common_data_1.VERSION],\n    [\n        // BSD based\n        /\\s([frentopc-]{0,4}bsd|dragonfly)\\s?([\\w\\.]+)*/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n    [\n        /(ip[honead]+)(?:.*os\\s*([\\w]+)*\\slike\\smac|;\\sopera)/i, // iOS\n    ],\n    [\n        [common_data_1.NAME, \"iOS\"],\n        [common_data_1.VERSION, /_/g, \".\"],\n    ],\n    [\n        /(mac\\sos\\sx)\\s?([\\w\\s\\.]+\\w)*/i,\n        /(macintosh|mac(?=_powerpc)\\s)/i, // Mac OS\n    ],\n    [\n        [common_data_1.NAME, \"Mac OS\"],\n        [common_data_1.VERSION, /_/g, \".\"],\n    ],\n    [\n        // Other\n        /((?:open)?solaris)[\\/\\s-]?([\\w\\.]+)*/i, // Solaris\n        /(haiku)\\s(\\w+)/i, // Haiku\n        /(aix)\\s((\\d)(?=\\.|\\)|\\s)[\\w\\.]*)*/i, // AIX\n        /(plan\\s9|minix|beos|os\\/2|amigaos|morphos|risc\\sos|openvms)/i,\n        // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS\n        /(unix)\\s?([\\w\\.]+)*/i, // UNIX\n    ],\n    [common_data_1.NAME, common_data_1.VERSION],\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageTransformer = void 0;\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst extendedImage_lib_1 = require(\"./extendedImage.lib\");\nconst console_logger_1 = require(\"../console.logger\");\n/**\n * Image Transformer class\n * @class ImageTransformer\n * @param {ImageUploaderSettings} settings - Configuration settings\n * @constructor\n * @scope public\n * @property {ImageUploaderSettings} settings - The configuration settings for the image transformer\n * @property {Logger} logger - Logger instance for logging messages\n */\nclass ImageTransformer {\n    constructor(settings) {\n        this.settings = settings;\n        this.logger = console_logger_1.Logger.getInstance();\n    }\n    /**\n     * Resize a blob or image file to the specified dimensions\n     * @param {ExtendedFile} file - The file to resize\n     * @returns {Promise<ResizeResult>} - Resolves with the resized blob or rejects with an error\n     */\n    resizeToBlob(file) {\n        const that = this;\n        return new Promise((resolve, reject) => {\n            try {\n                const params = that.settings.resize || false;\n                // Create a new Image instance\n                const img = new extendedImage_lib_1.ExtendedImage(true);\n                img.on(\"load\", function () {\n                    if (!params || (params.width > this.width && params.height > this.height && params.quality === undefined)) {\n                        that.logger.debug(\"No resize needed for file\", file.name);\n                        this.getAsBlob(1)\n                            .then((blob) => {\n                            this.destroy();\n                            resolve({ blob, file }); // No resize needed\n                        })\n                            .catch((error) => {\n                            that.logger.error(\"Error getting blob without resize:\", error);\n                            reject(new Error(`Image resize failed: ${error.message}`));\n                        });\n                    }\n                    else {\n                        //params.quality = 0.1;\n                        that.logger.debug(\"Resizing file\", file.name, \"to\", params.width, \"x\", params.height, \"at quality\", params.quality);\n                        img.downsize(params.width, params.height, \"image/jpeg\", params.quality, params.crop, true, false, params.preserveHeaders, false);\n                    }\n                });\n                img.on(\"resize\", function () {\n                    this.getAsBlob(params ? params.quality : 1)\n                        .then((resizedBlob) => {\n                        const resizedFile = new extendedFile_lib_1.ExtendedFile(new File([resizedBlob], file.name, {\n                            type: resizedBlob.type,\n                            lastModified: Date.now(),\n                        }), { id: file.id });\n                        this.destroy();\n                        that.logger.debug(\"Resized file\", file.name, \"to blob size\", resizedBlob.size);\n                        resolve({ blob: resizedBlob, file: resizedFile });\n                    })\n                        .catch((error) => {\n                        that.logger.error(\"Error getting resized blob:\", error);\n                        this.destroy();\n                        reject(error);\n                    });\n                });\n                img.bind(\"error runtimeerror\", function (error) {\n                    that.logger.error(\"Resize error: \", error);\n                    this.destroy();\n                    resolve({ blob: null, file: file }); // Fallback to original file on error\n                });\n                // Load the file into the image object\n                img.load(file.getSource()).catch(reject);\n            }\n            catch (error) {\n                this.logger.error(\"Blob resize error\", error);\n                reject(new Error(`Blob resize failed: ${error.message}`));\n            }\n        });\n    }\n}\nexports.ImageTransformer = ImageTransformer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.is_plain_object = is_plain_object;\nexports.var_export = var_export;\nexports.var_dump = var_dump;\nexports.is_numeric = is_numeric;\nexports.prop_exists = prop_exists;\nexports.merge_options = merge_options;\nexports.is_uri = is_uri;\nexports.deep_clone = deep_clone;\nexports.debounce = debounce;\nexports.throttle = throttle;\nexports.deferPromise = deferPromise;\n/**\n * Check if a value is a plain object.\n * @param {any} e - The value to check.\n * @returns {boolean} - True if the value is a plain object, false otherwise.\n */\nfunction is_plain_object(e) {\n    var t, n;\n    return (!(!e || \"[object Object]\" !== Object.prototype.toString.call(e)) &&\n        (!(t = Object.getPrototypeOf(e)) ||\n            (\"function\" == typeof (n = Object.prototype.hasOwnProperty.call(t, \"constructor\") && t.constructor) &&\n                Function.prototype.toString.call(n) === Function.prototype.toString.call(Object))));\n}\n/**\n * Check if a value is an array.\n * @param {any} e - The value to check.\n * @returns {boolean} - True if the value is an array, false otherwise.\n */\nfunction is_array(e) {\n    return Array.isArray(e);\n}\n/**\n * Deep merge two values.\n * @param {T} target - The target value to merge into.\n * @param {U} source - The source value to merge from.\n * @returns {DeepMerge<T, U>} - The merged value.\n * @description\n * - Plain objects are merged by key.\n * - Arrays are merged element-wise by index.\n * - Date, RegExp, Map, Set are cloned.\n * - On type mismatch or non-mergeable, the source value wins.\n */\nfunction deep_merge(target, source) {\n    const get_type = (val) => Object.prototype.toString.call(val).slice(8, -1);\n    // If source is undefined, just clone target\n    if (source === undefined)\n        return clone_value(target);\n    const tType = get_type(target);\n    const sType = get_type(source);\n    // On type mismatch, override\n    if (tType !== sType) {\n        return clone_value(source);\n    }\n    // Merge arrays\n    if (sType === \"Array\") {\n        const res = [];\n        const maxLen = Math.max(target.length, source.length);\n        for (let i = 0; i < maxLen; i++) {\n            if (i in source) {\n                if (i in target) {\n                    res[i] = deep_merge(target[i], source[i]);\n                }\n                else {\n                    res[i] = clone_value(source[i]);\n                }\n            }\n            else {\n                res[i] = clone_value(target[i]);\n            }\n        }\n        return res;\n    }\n    // Merge plain objects\n    if (sType === \"Object\") {\n        const res = {};\n        // first copy all keys from target\n        for (const key of Reflect.ownKeys(target)) {\n            if (typeof key === \"symbol\") {\n                res[key] = clone_value(target[key]);\n            }\n            else {\n                res[key] = clone_value(target[key]);\n            }\n        }\n        // then merge/override with source\n        for (const key of Reflect.ownKeys(source)) {\n            if (typeof key === \"symbol\") {\n                if (key in target) {\n                    res[key] = deep_merge(target[key], source[key]);\n                }\n                else {\n                    res[key] = clone_value(source[key]);\n                }\n            }\n            else {\n                if (key in target) {\n                    res[key] = deep_merge(target[key], source[key]);\n                }\n                else {\n                    res[key] = clone_value(source[key]);\n                }\n            }\n        }\n        return res;\n    }\n    // Clone Dates\n    if (sType === \"Date\") {\n        return new Date(source.getTime());\n    }\n    // Clone RegExps\n    if (sType === \"RegExp\") {\n        const re = source;\n        return new RegExp(re.source, re.flags);\n    }\n    // Clone Maps\n    if (sType === \"Map\") {\n        const m = new Map();\n        source.forEach((v, k) => {\n            m.set(k, clone_value(v));\n        });\n        return m;\n    }\n    // Clone Sets\n    if (sType === \"Set\") {\n        const s = new Set();\n        source.forEach((v) => {\n            s.add(clone_value(v));\n        });\n        return s;\n    }\n    // Functions, primitives, symbols, etc.  override\n    return source;\n}\n/**\n * Clone a value deeply.\n * @description shallow-clone built-ins or return primitives as-is\n * @param {any} val - The value to clone.\n * @return {any} - The cloned value.\n */\nfunction clone_value(val) {\n    const type = Object.prototype.toString.call(val).slice(8, -1);\n    const result = {};\n    switch (type) {\n        case \"Array\":\n            return val.map(clone_value);\n        case \"Object\":\n            // Copy regular properties\n            for (const key of Object.keys(val)) {\n                result[key] = val[key];\n            }\n            // Copy symbol properties\n            for (const sym of Object.getOwnPropertySymbols(val)) {\n                result[sym] = val[sym];\n            }\n            return result;\n        case \"Date\":\n            return new Date(val.getTime());\n        case \"RegExp\": {\n            const r = val;\n            return new RegExp(r.source, r.flags);\n        }\n        case \"Map\": {\n            const m = new Map();\n            val.forEach((v, k) => m.set(k, clone_value(v)));\n            return m;\n        }\n        case \"Set\": {\n            const s = new Set();\n            val.forEach((v) => s.add(clone_value(v)));\n            return s;\n        }\n        default:\n            return val; // primitives, functions, symbols\n    }\n}\nfunction echo(...args) {\n    //  discuss at: https://locutus.io/php/echo/\n    // original by: Philip Peterson\n    // improved by: echo is bad\n    // improved by: Nate\n    // improved by: Brett Zamir (https://brett-zamir.me)\n    // improved by: Brett Zamir (https://brett-zamir.me)\n    // improved by: Brett Zamir (https://brett-zamir.me)\n    //  revised by: Der Simon (https://innerdom.sourceforge.net/)\n    // bugfixed by: Eugene Bulkin (https://doubleaw.com/)\n    // bugfixed by: Brett Zamir (https://brett-zamir.me)\n    // bugfixed by: Brett Zamir (https://brett-zamir.me)\n    // bugfixed by: EdorFaus\n    //      note 1: In 1.3.2 and earlier, this function wrote to the body of the document when it\n    //      note 1: was called in webbrowsers, in addition to supporting XUL.\n    //      note 1: This involved >100 lines of boilerplate to do this in a safe way.\n    //      note 1: Since I can't imageine a complelling use-case for this, and XUL is deprecated\n    //      note 1: I have removed this behavior in favor of just calling `console.log`\n    //      note 2: You'll see functions depends on `echo` instead of `console.log` as we'll want\n    //      note 2: to have 1 contact point to interface with the outside world, so that it's easy\n    //      note 2: to support other ways of printing output.\n    //  revised by: Kevin van Zonneveld (https://kvz.io)\n    //    input by: JB\n    //   example 1: echo('Hello world')\n    //   returns 1: undefined\n    return console.log(args.join(\" \"));\n}\n/**\n * Returns the name of a function.\n * @param {Function} fn - The function to get the name of.\n * @returns {string} - The name of the function, or \"(Anonymous)\" if it has no name.\n */\nfunction _getFuncName(fn) {\n    const name = /\\W*function\\s+([\\w$]+)\\s*\\(/.exec(fn.toString());\n    if (!name) {\n        return \"(Anonymous)\";\n    }\n    return name[1];\n}\n/**\n * Checks if a string is a normal integer (non-negative, finite, and not NaN).\n * @param {string} string - The string to check.\n * @returns {boolean} - True if the string is a normal integer, false otherwise.\n */\nfunction _isNormalInteger(string) {\n    const number = Math.floor(Number(string));\n    return number !== Infinity && String(number) === string && number >= 0;\n}\n/**\n * Creates an indentation string based on the given indentation level.\n * @param {number} idtLevel - The indentation level.\n * @returns {string} - The indentation string.\n */\nfunction _makeIndent(idtLevel) {\n    return new Array(idtLevel + 1).join(\" \");\n}\n/**\n * Returns the type of a value.\n * @param {any} inp - The value to get the type of.\n * @returns {string} - The type of the value.\n */\nfunction __getType(inp) {\n    let i = 0;\n    let match;\n    let types;\n    let cons;\n    let type = typeof inp;\n    if (type === \"object\" && inp && inp.constructor && _getFuncName(inp.constructor) === \"LOCUTUS_Resource\") {\n        return \"resource\";\n    }\n    if (type === \"function\") {\n        return \"function\";\n    }\n    if (type === \"object\" && !inp) {\n        // Should this be just null?\n        return \"null\";\n    }\n    if (type === \"object\") {\n        if (!inp.constructor) {\n            return \"object\";\n        }\n        cons = inp.constructor.toString();\n        match = cons.match(/(\\w+)\\(/);\n        if (match) {\n            cons = match[1].toLowerCase();\n        }\n        types = [\"boolean\", \"number\", \"string\", \"array\"];\n        for (i = 0; i < types.length; i++) {\n            if (cons === types[i]) {\n                type = types[i];\n                break;\n            }\n        }\n    }\n    return type;\n}\n/**\n * Exports a variable in a human-readable format.\n * @description Javascript implementation of PHP's var_export function.\n * @param {any} mixedExpression - The variable to export.\n * @param {boolean} [boolReturn=false] - Whether to return the output as a string.\n * @param {number} [idtLevel=0] - The indentation level.\n * @returns {string|null} - The exported variable as a string, or null if not returning.\n */\nfunction var_export(mixedExpression, boolReturn, idtLevel) {\n    // Counter to track recursion depth - will be shared across all calls in this closure\n    let recursionDepth = 0;\n    const initialIdtLevel = idtLevel || 2;\n    function _var_export_impl(mixedExpression, boolReturn, idtLevel) {\n        recursionDepth++;\n        const isInitialCall = recursionDepth === 1;\n        let retstr = \"\";\n        let iret = \"\";\n        let value;\n        let cnt = 0;\n        const x = [];\n        let i = 0;\n        let funcParts;\n        // We use the last argument (not part of PHP) to pass in\n        // our indentation level\n        const idtLevelValue = idtLevel || 2;\n        let innerIndent = \"\";\n        let outerIndent = \"\";\n        const type = __getType(mixedExpression);\n        if (type === \"null\") {\n            retstr = \"NULL\";\n        }\n        else if (type === \"array\" || type === \"object\") {\n            outerIndent = _makeIndent(idtLevelValue - initialIdtLevel);\n            innerIndent = _makeIndent(idtLevelValue);\n            for (i in mixedExpression) {\n                value = \" \";\n                const subtype = __getType(mixedExpression[i]);\n                if (subtype === \"array\" || subtype === \"object\") {\n                    value = \"\\n\";\n                }\n                value += _var_export_impl(mixedExpression[i], true, idtLevelValue + initialIdtLevel);\n                i = _isNormalInteger(i) ? i : `'${i}'`;\n                x[cnt++] = innerIndent + i + \" =>\" + value;\n            }\n            if (x.length > 0) {\n                iret = x.join(\",\\n\") + \",\\n\";\n            }\n            retstr = (isInitialCall ? \"\" : outerIndent) + \"array (\\n\" + iret + outerIndent + \")\";\n        }\n        else if (type === \"function\") {\n            funcParts = mixedExpression.toString().match(/function .*?\\((.*?)\\) \\{([\\s\\S]*)\\}/);\n            retstr = \"create_function ('\" + funcParts[1] + \"', '\" + funcParts[2].replace(/'/g, \"\\\\'\") + \"')\";\n            retstr = retstr.replace(/[\\r\\n]+/g, \".*\"); // Replace newlines with .*\n        }\n        else if (type === \"resource\") {\n            // Resources treated as null for var_export\n            retstr = \"NULL\";\n        }\n        else {\n            retstr =\n                typeof mixedExpression !== \"string\"\n                    ? String(mixedExpression)\n                    : \"'\" + mixedExpression.replace(/(['])/g, \"\\\\$1\").replace(/\\0/g, \"\\\\0\") + \"'\";\n        }\n        recursionDepth--;\n        if (!boolReturn)\n            echo(retstr);\n        return boolReturn ? retstr : null;\n    }\n    return _var_export_impl(mixedExpression, boolReturn, idtLevel);\n}\n/**\n * Repeats a character a specified number of times.\n * @param {number} len - The number of times to repeat the character.\n * @param {string} padChar - The character to repeat.\n * @returns {string} - The repeated character string.\n */\nfunction _repeatChar(len, padChar) {\n    let str = \"\";\n    for (let i = 0; i < len; i++) {\n        str += padChar;\n    }\n    return str;\n}\n/**\n * Gets the inner value of a variable for `var_dump`.\n * @param {any} val - The value to get the inner value of.\n * @param {string} thickPad - The padding string for formatting.\n * @returns {string} - The formatted inner value.\n */\nfunction _getInnerVal(val, thickPad) {\n    let ret = \"\";\n    if (val === null) {\n        ret = \"NULL\";\n    }\n    else if (typeof val === \"boolean\") {\n        ret = \"bool(\" + val + \")\";\n    }\n    else if (typeof val === \"string\") {\n        ret = \"string(\" + val.length + ') \"' + val + '\"';\n    }\n    else if (typeof val === \"number\") {\n        if (parseFloat(`${val}`) === parseInt(`${val}`, 10)) {\n            ret = \"int(\" + val + \")\";\n        }\n        else {\n            ret = \"float(\" + val + \")\";\n        }\n    }\n    else if (typeof val === \"undefined\") {\n        // The remaining are not PHP behavior because these values\n        // only exist in this exact form in JavaScript\n        ret = \"undefined\";\n    }\n    else if (typeof val === \"function\") {\n        const funcLines = val.toString().split(\"\\n\");\n        ret = \"\";\n        for (let i = 0, fll = funcLines.length; i < fll; i++) {\n            ret += (i !== 0 ? \"\\n\" + thickPad : \"\") + funcLines[i];\n        }\n    }\n    else if (val instanceof Date) {\n        ret = \"Date(\" + val + \")\";\n    }\n    else if (val instanceof RegExp) {\n        ret = \"RegExp(\" + val + \")\";\n    }\n    else if (val.nodeName) {\n        // Different than PHP's DOMElement\n        switch (val.nodeType) {\n            case 1:\n                if (typeof val.namespaceURI === \"undefined\" || /https?:\\/\\/www\\.w3\\.org\\/1999\\/xhtml/i.test(val.namespaceURI)) {\n                    // Undefined namespace could be plain XML, but namespaceURI not widely supported\n                    ret = 'HTMLElement(\"' + val.nodeName + '\")';\n                }\n                else {\n                    ret = 'XML Element(\"' + val.nodeName + '\")';\n                }\n                break;\n            case 2:\n                ret = \"ATTRIBUTE_NODE(\" + val.nodeName + \")\";\n                break;\n            case 3:\n                ret = \"TEXT_NODE(\" + val.nodeValue + \")\";\n                break;\n            case 4:\n                ret = \"CDATA_SECTION_NODE(\" + val.nodeValue + \")\";\n                break;\n            case 5:\n                ret = \"ENTITY_REFERENCE_NODE\";\n                break;\n            case 6:\n                ret = \"ENTITY_NODE\";\n                break;\n            case 7:\n                ret = \"PROCESSING_INSTRUCTION_NODE(\" + val.nodeName + \":\" + val.nodeValue + \")\";\n                break;\n            case 8:\n                ret = \"COMMENT_NODE(\" + val.nodeValue + \")\";\n                break;\n            case 9:\n                ret = \"DOCUMENT_NODE\";\n                break;\n            case 10:\n                ret = \"DOCUMENT_TYPE_NODE\";\n                break;\n            case 11:\n                ret = \"DOCUMENT_FRAGMENT_NODE\";\n                break;\n            case 12:\n                ret = \"NOTATION_NODE\";\n                break;\n        }\n    }\n    return ret;\n}\n/**\n * Formats an array or object for `var_dump`.\n * @param {any} obj - The object or array to format.\n * @param {number} curDepth - The current depth of recursion.\n * @param {number} padVal - The padding value for indentation.\n * @param {string} padChar - The character to use for padding.\n * @param {Map<any, boolean>} visitedObjects - Map to track visited objects to prevent circular references.\n * @returns {string} - The formatted string representation of the object or array.\n */\nfunction _formatArray(obj, curDepth, padVal, padChar, visitedObjects) {\n    if (curDepth > 0) {\n        curDepth++;\n    }\n    const basePad = _repeatChar(padVal * (curDepth - 1), padChar);\n    const thickPad = _repeatChar(padVal * (curDepth + 1), padChar);\n    let str = \"\";\n    let val = \"\";\n    let lgth = 0;\n    if (typeof obj === \"object\" && obj !== null && (is_plain_object(obj) || is_array(obj))) {\n        if (visitedObjects.has(obj)) {\n            // Circular reference detected, return a placeholder or a message\n            return \"Circular Reference Detected\\n\";\n        }\n        else {\n            // Mark this object as visited by adding it to the map\n            visitedObjects.set(obj, true);\n        }\n        if (obj.constructor && _getFuncName(obj.constructor) === \"LOCUTUS_Resource\") {\n            return obj.var_dump();\n        }\n        lgth = 0;\n        for (const someProp in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, someProp)) {\n                lgth++;\n            }\n        }\n        str += \"array(\" + lgth + \") {\\n\";\n        for (const key in obj) {\n            const objVal = obj[key];\n            if (typeof objVal === \"object\" &&\n                objVal !== null &&\n                !(objVal instanceof Date) &&\n                !(objVal instanceof RegExp) &&\n                !objVal.nodeName) {\n                str += thickPad;\n                str += \"[\";\n                str += key;\n                str += \"] =>\\n\";\n                str += thickPad;\n                str += _formatArray(objVal, curDepth + 1, padVal, padChar, visitedObjects);\n            }\n            else {\n                val = _getInnerVal(objVal, thickPad);\n                str += thickPad;\n                str += \"[\";\n                str += key;\n                str += \"] =>\\n\";\n                str += thickPad;\n                str += val;\n                str += \"\\n\";\n            }\n        }\n        str += basePad + \"}\\n\";\n    }\n    else {\n        str = _getInnerVal(obj, thickPad);\n    }\n    return str;\n}\nconst visitedObjects = new Map(); // Initialize a map to track visited objects\n/**\n * Dumps a variable in a human-readable format.\n * @description JavaScript implementation of PHP's var_dump function.\n * @param {...any} args - The variables to dump.\n * @returns {string} - The dumped output as a string.\n */\nfunction var_dump(...args) {\n    let output = \"\";\n    const padChar = \" \";\n    const padVal = 4; // Padding value for indentation\n    let i = 0;\n    output = _formatArray(args[0], 0, padVal, padChar, visitedObjects);\n    for (i = 1; i < args.length; i++) {\n        output += \"\\n\" + _formatArray(args[i], 0, padVal, padChar, visitedObjects);\n    }\n    echo(output);\n    // Not how PHP does it, but helps us test:\n    return output;\n}\nfunction is_numeric(mixedVar) {\n    //  discuss at: https://locutus.io/php/is_numeric/\n    // original by: Kevin van Zonneveld (https://kvz.io)\n    // improved by: David\n    // improved by: taith\n    // bugfixed by: Tim de Koning\n    // bugfixed by: WebDevHobo (https://webdevhobo.blogspot.com/)\n    // bugfixed by: Brett Zamir (https://brett-zamir.me)\n    // bugfixed by: Denis Chenu (https://shnoulle.net)\n    //   example 1: is_numeric(186.31)\n    //   returns 1: true\n    //   example 2: is_numeric('Kevin van Zonneveld')\n    //   returns 2: false\n    //   example 3: is_numeric(' +186.31e2')\n    //   returns 3: true\n    //   example 4: is_numeric('')\n    //   returns 4: false\n    //   example 5: is_numeric([])\n    //   returns 5: false\n    //   example 6: is_numeric('1 ')\n    //   returns 6: false\n    const whitespace = [\n        \" \",\n        \"\\n\",\n        \"\\r\",\n        \"\\t\",\n        \"\\f\",\n        \"\\x0b\",\n        \"\\xa0\",\n        \"\\u2000\",\n        \"\\u2001\",\n        \"\\u2002\",\n        \"\\u2003\",\n        \"\\u2004\",\n        \"\\u2005\",\n        \"\\u2006\",\n        \"\\u2007\",\n        \"\\u2008\",\n        \"\\u2009\",\n        \"\\u200a\",\n        \"\\u200b\",\n        \"\\u2028\",\n        \"\\u2029\",\n        \"\\u3000\",\n    ].join(\"\");\n    // @todo: Break this up using many single conditions with early returns\n    return ((typeof mixedVar === \"number\" || (typeof mixedVar === \"string\" && whitespace.indexOf(mixedVar.slice(-1)) === -1)) &&\n        mixedVar !== \"\" &&\n        !isNaN(mixedVar) &&\n        isFinite(mixedVar));\n}\n/**\n * prop_exists\n * @function prop_exists\n * @description Checks if a property exists in an object at a given path.\n * @param {Record<string, any>} obj - The object to check.\n * @param {string} path - The dot-separated path to the property.\n * @returns {boolean} - True iff the property exists, false otherwise.\n */\nfunction prop_exists(obj, path) {\n    // split on dot, filter out accidental empty segments\n    const keys = path.split(\".\").filter(Boolean);\n    let current = obj;\n    if (!current || [undefined, null, \"\"].includes(path) || keys.length === 0)\n        return false;\n    if (!Object.prototype.hasOwnProperty.call(current, path)) {\n        for (const key of keys) {\n            // if current is null/undefined, or doesn't have its own key, bail\n            if (typeof current === \"undefined\" || current == null || !Object.prototype.hasOwnProperty.call(current, key)) {\n                return false;\n            }\n            current = current[key];\n        }\n    }\n    return true;\n}\n/**\n * merge_options\n * @function merge_options\n * @description Merges two option objects, with the override object taking precedence.\n * @param {T} base - The base options object.\n * @param {U} override - The options to override the base.\n * @param {string[]} [required] - Optional array of required properties that must exist in the override.\n * @returns {DeepMerge<T, U> | undefined} - The merged options object.\n */\nfunction merge_options(base, override, required) {\n    if (required && is_array(required)) {\n        for (const key of required) {\n            if (!is_plain_object(override) || !prop_exists(override, key)) {\n                return undefined; // or throw an error if you prefer\n            }\n        }\n    }\n    return deep_merge(base, override);\n}\n/**\n * Validates if a string is a valid URI.\n * @param {string} address - The string to validate.\n * @returns {boolean} - True if the string is a valid URI, false otherwise.\n */\nfunction is_uri(address) {\n    if (typeof address !== \"string\")\n        return false;\n    const s = address.trim();\n    const ABSOLUTE_URL_REGEX = \"^(?<protocol>https?:\\/\\/)\" + // Match http or https\n        \"(?:(?<host>[A-Za-z0-9\\\\-]+)\\\\.)+\" + // Match domain name\n        \"(?<tld>[A-Za-z]{2,63})\" + // Match TLD (2 or more letters)\n        \"(?::(?<port>[0-9]{1,5}))?\" + // Optional port number\n        \"(?<path>\\/[A-Za-z0-9\\\\-._~%!$&'()*+,;=:@%]*)*\" + // Optional path\n        \"(?<query>\\\\?[A-Za-z0-9\\\\-._~%!$&'()*\\\\+,;=:@%\\/?=]*)?\" + // Optional query string\n        \"(?<fragment>#[A-Za-z0-9\\\\-._~%!$&'()*\\\\+,;=:@%\\/?=]*)?$\"; // Optional fragment\n    const absoluteUrlPattern = new RegExp(ABSOLUTE_URL_REGEX, \"i\");\n    const RELATIVE_URL_REGEX = \"^(?!\\s*$)\" + // not empty\n        \"(?![^A-Za-z0-9]+$)\" + // alphanumeric\n        \"(?![^\\/\\\\.]+$)\" + // file extension or path delimiter required\n        \"(?![A-Za-z][A-Za-z0-9+.-]*:)\" + // no scheme:\n        \"(?!\\/\\/)\" + // no protocol-relative\n        \"(?<leading>\\/)?\" + // optional leading slash\n        \"(?<path>[A-Za-z0-9\\-_().]+\" + // one segment\n        \"(?:\\/(?<leaf>[A-Za-z0-9\\-_().]+))*)\" + // then 0+ more\n        \"(?<query>\\\\?[A-Za-z0-9=&_%\\\\-\\\\+.]+)?\" + // optional query\n        \"(?<fragment>#[A-Za-z0-9\\\\-_]+)?$\"; // optional fragment\n    const relativeUrlPattern = new RegExp(RELATIVE_URL_REGEX, \"i\");\n    return absoluteUrlPattern.test(s) || relativeUrlPattern.test(s);\n}\n/**\n * Deepclone a value, preserving Blobs, ArrayBuffers, TypedArrays,\n * Dates, RegExps, Maps, Sets, Arrays and plain objects.\n * @param {T} value - The value to deep clone.\n * @returns {T} - The deep cloned value.\n * @throws {Error} - If the value cannot be cloned.\n */\nfunction deep_clone(value) {\n    // Primitives, functions, null, etc.\n    if (value === null || typeof value !== \"object\") {\n        return value;\n    }\n    // Native structuredClone?\n    if (typeof structuredClone === \"function\") {\n        try {\n            return structuredClone(value);\n        }\n        catch (e) {\n            // If structuredClone fails, fall back to manual cloning\n            console.debug(\"structuredClone failed, falling back to manual deep_clone\", e);\n        }\n    }\n    // Blob\n    if (value instanceof Blob) {\n        return value.slice(0, value.size, value.type);\n    }\n    // ArrayBuffer\n    if (value instanceof ArrayBuffer) {\n        return value.slice(0);\n    }\n    // TypedArray or DataView\n    if (ArrayBuffer.isView(value)) {\n        const buffer = value.buffer;\n        const byteOffset = value.byteOffset;\n        const byteLength = value.byteLength;\n        const ctor = value.constructor;\n        const copiedBuffer = new ArrayBuffer(byteLength);\n        const src = new Uint8Array(buffer, byteOffset, byteLength);\n        new Uint8Array(copiedBuffer).set(src);\n        // Handle both TypedArrays and DataView\n        if (value instanceof DataView) {\n            return new DataView(copiedBuffer);\n        }\n        else {\n            return new ctor(copiedBuffer);\n        }\n    }\n    // Date\n    if (value instanceof Date) {\n        return new Date(value.getTime());\n    }\n    // RegExp\n    if (value instanceof RegExp) {\n        return new RegExp(value.source, value.flags);\n    }\n    // Map\n    if (value instanceof Map) {\n        const m = new Map();\n        for (const [k, v] of value.entries()) {\n            m.set(deep_clone(k), deep_clone(v));\n        }\n        return m;\n    }\n    // Set\n    if (value instanceof Set) {\n        const s = new Set();\n        for (const v of value.values()) {\n            s.add(deep_clone(v));\n        }\n        return s;\n    }\n    // Array\n    if (Array.isArray(value)) {\n        return value.map((el) => deep_clone(el));\n    }\n    // Plain object\n    const out = {};\n    for (const key of Object.keys(value)) {\n        out[key] = deep_clone(value[key]);\n    }\n    return out;\n}\n/**\n * Debounces a function, ensuring it is not called again until a specified wait time has passed\n * @param {Function} fn - The function to debounce\n * @param {number} [wait=300] - The wait time in milliseconds\n * @param {Object} [options] - The options object\n * @param {boolean} [options.leading=false] - Whether to invoke the function on the leading edge\n * @param {boolean} [options.trailing=true] - Whether to invoke the function on the trailing edge\n * @returns {Function} - The debounced function\n */\nfunction debounce(fn, wait = 300, options = {}) {\n    const { leading = false, trailing = true } = options;\n    let t;\n    let lastArgs;\n    let lastThis;\n    let leadingInvoked = false;\n    const invoke = () => {\n        const args = lastArgs;\n        const ctx = lastThis;\n        lastArgs = lastThis = undefined;\n        leadingInvoked = true;\n        return fn.apply(ctx, args);\n    };\n    const debounced = function (...args) {\n        lastArgs = args;\n        lastThis = this;\n        if (!t) {\n            if (leading)\n                invoke();\n            t = window.setTimeout(() => {\n                t = undefined;\n                if (trailing && (!leading || leadingInvoked))\n                    invoke();\n                leadingInvoked = false;\n            }, wait);\n        }\n        else {\n            clearTimeout(t);\n            t = window.setTimeout(() => {\n                t = undefined;\n                if (trailing)\n                    invoke();\n                leadingInvoked = false;\n            }, wait);\n        }\n    };\n    debounced.cancel = () => {\n        if (t)\n            clearTimeout(t);\n        t = undefined;\n        lastArgs = lastThis = undefined;\n        leadingInvoked = false;\n    };\n    debounced.flush = () => {\n        if (t) {\n            clearTimeout(t);\n            t = undefined;\n            if (trailing)\n                invoke();\n            leadingInvoked = false;\n        }\n    };\n    return debounced;\n}\n/**\n * Throttles a function, ensuring it is not called more than once in a specified wait time\n * @param {Function} fn - The function to throttle\n * @param {number} wait - The wait time in milliseconds\n * @param {Object} [options] - The options object\n * @param {boolean} [options.leading=true] - Whether to invoke the function on the leading edge\n * @param {boolean} [options.trailing=true] - Whether to invoke the function on the trailing edge\n * @returns {Function} - The throttled function\n */\nfunction throttle(fn, wait, options = {}) {\n    const { leading = true, trailing = true } = options;\n    let lastCallTime = null;\n    let timeout;\n    let lastArgs;\n    let lastThis;\n    const invoke = () => {\n        lastCallTime = Date.now();\n        fn.apply(lastThis, lastArgs);\n        lastArgs = lastThis = null;\n    };\n    return function (...args) {\n        const now = Date.now();\n        const isInvoking = lastCallTime === null || now - lastCallTime >= wait;\n        lastArgs = args;\n        lastThis = this;\n        if (isInvoking) {\n            if (leading) {\n                invoke();\n            }\n            else {\n                lastCallTime = now;\n            }\n        }\n        else if (trailing && !timeout) {\n            timeout = window.setTimeout(() => {\n                timeout = undefined;\n                if (trailing && lastArgs)\n                    invoke();\n            }, wait - (now - lastCallTime));\n        }\n    };\n}\n/**\n * Creates a deferred promise.\n * @param {string} id - The ID of the deferred promise.\n * @returns {Deferred<T>} - The deferred promise.\n */\nfunction deferPromise(id) {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { id, promise, resolve, reject };\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UploadPipeline = void 0;\nconst console_logger_1 = __importDefault(require(\"../console.logger\"));\nconst defaults_data_1 = require(\"../data/uploader/defaults.data\");\nconst common_1 = require(\"../types/common\");\nconst functions_1 = require(\"../utils/functions\");\nconst eventManager_lib_1 = require(\"./eventManager.lib\");\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst feature_lib_1 = require(\"./feature.lib\");\nconst imageTransformer_lib_1 = require(\"./imageTransformer.lib\");\nconst queueManager_lib_1 = require(\"./queueManager.lib\");\nconst requestFactory_lib_1 = require(\"./requestFactory.lib\");\nconst thumbnailService_lib_1 = require(\"./thumbnailService.lib\");\n/**\n * UploadPipeline class for managing the upload pipeline.\n * @class\n * @property {ExtendedFile[]} files - The files to be uploaded.\n * @property {ImageUploaderSettings} settings - The settings for the image uploader.\n * @property {Logger} logger - The logger instance.\n * @property {ThumbnailService} thumbnailService - The thumbnail service instance.\n * @property {ImageTransformer} imageTransformer - The image transformer instance.\n * @property {EventManager} eventManager - The event manager instance.\n * @property {UploadRequestFactory} requestFactory - The request factory instance.\n * @property {QueueManager} ticketQueue - The ticket queue manager instance.\n * @property {QueueManager} transformQueue - The transform queue manager instance.\n * @property {QueueManager} requestQueue - The request queue manager instance.\n */\nclass UploadPipeline {\n    /**\n     * Creates an instance of UploadPipeline.\n     * @param {ExtendedFile[]} files - The files to be uploaded.\n     * @param {ImageUploaderSettings} settings - The settings for the image uploader.\n     * @scope public\n     * @constructor\n     */\n    constructor(settings) {\n        this.active = false;\n        this.settings = settings;\n        this.logger = console_logger_1.default.getInstance();\n        this.thumbnailService = new thumbnailService_lib_1.ThumbnailService(this.settings);\n        this.imageTransformer = new imageTransformer_lib_1.ImageTransformer(this.settings);\n        this.eventManager = eventManager_lib_1.EventManager.getInstance(settings);\n        this.requestFactory = new requestFactory_lib_1.UploadRequestFactory(this.settings);\n        this.ticketQueue = new queueManager_lib_1.QueueManager(1);\n        this.transformQueue = new queueManager_lib_1.QueueManager(defaults_data_1.PIPELINE_CONCURRENCY.transform);\n        this.requestQueue = new queueManager_lib_1.QueueManager(1);\n        this.promises = {\n            ticket: new Map(),\n            transform: new Map(),\n        };\n        this.batchSize = this._normalizeBatchSize(this.settings.s3Options?.batch);\n    }\n    /**\n     * Checks if the current upload is active.\n     * @returns {boolean} - True if the upload is active, false otherwise.\n     * @scope public\n     */\n    isActive() {\n        return this.active;\n    }\n    /**\n     * Resets the upload pipeline state\n     * @returns {void}\n     * @scope public\n     */\n    reset() {\n        try {\n            this.active = false;\n            this.ticketQueue.clear();\n            this.transformQueue.clear();\n            this.requestQueue.clear();\n            this.promises = {\n                ticket: new Map(),\n                transform: new Map(),\n            };\n            this.ticketQueue.setConcurrency(1);\n            this.transformQueue.setConcurrency(defaults_data_1.PIPELINE_CONCURRENCY.transform);\n            this.requestQueue.setConcurrency(1);\n            console.debug(\"UploadPipeline reset.\");\n        }\n        catch (error) {\n            console.error(\"Error during reset:\", error);\n        }\n    }\n    /**\n     * Starts the upload process.\n     * @param {ExtendedFile[]} files - The files to be uploaded.\n     * @returns {Promise<any>}\n     * @scope public\n     */\n    process(files) {\n        this.active = true;\n        this.logger.debug(`Starting upload pipeline with ${files.length} files.`);\n        this.logger.debug(\"Starting upload pipeline with queue concurrencies:\", JSON.stringify({\n            ticket: this.ticketQueue.getConcurrency(),\n            transform: this.transformQueue.getConcurrency(),\n            request: this.requestQueue.getConcurrency(),\n        }));\n        const onProgressThrottled = (0, functions_1.throttle)(this._onQueueProgress.bind(this), 2000);\n        // Kick off presigns + transforms immediately (guarded by concurrency + memoization)\n        for (let i = 0; i < files.length; i += this.batchSize) {\n            const batch = files.slice(i, i + this.batchSize);\n            if (this._hasBatchS3Tickets())\n                this._batchQueueTickets(batch);\n            else\n                batch.map((file) => this._queueTicket(file));\n            batch.map((file) => this._queueTransform(file));\n        }\n        // Upload once a files presign + blob are both ready\n        const tasks = files.map((file) => Promise.all([this._queueTicket(file), this._queueTransform(file)])\n            .then(([ticket, { file, blob }]) => this._queueRequest(blob, file, ticket))\n            .then(() => {\n            // log loads here, if needed\n        })\n            .then(() => onProgressThrottled())\n            .catch((err) => {\n            if (file.status === common_1.FILE_STATUS.QUEUED)\n                file.status = common_1.FILE_STATUS.CANCELED;\n            this.logger.error(`Error processing upload for ${file.name}:`, err);\n        }));\n        // drain all queues\n        return Promise.allSettled(tasks)\n            .then(() => Promise.all([this.ticketQueue.wait(), this.transformQueue.wait(), this.requestQueue.wait()]))\n            .then(() => {\n            this.active = false;\n        });\n    }\n    /**\n     * Queues a ticket request for a file.\n     * @param {ExtendedFile} file - The file to queue the ticket for.\n     * @returns {TicketPromise}\n     * @scope private\n     */\n    _queueTicket(file) {\n        const id = file.id;\n        if (!this._isS3TransportMode())\n            return Promise.resolve(undefined);\n        if (!this.promises.ticket.has(id)) {\n            // cludge for missing S3 PUT ticket in batch mode\n            if (this._hasBatchS3Tickets()) {\n                return Promise.reject(new Error(`No S3 PUT ticket available for file ${file.name}.`));\n            }\n            else {\n                this.promises.ticket.set(id, this.ticketQueue.enqueue(() => this._getTicket(file)));\n            }\n        }\n        return this.promises.ticket.get(id);\n    }\n    /**\n     * Queues a transform request for a file.\n     * @param {ExtendedFile} file - The file to queue the transform for.\n     * @returns {TransformPromise}\n     * @scope private\n     */\n    _queueTransform(file) {\n        const id = file.id;\n        if (!this.promises.transform.has(id)) {\n            this.promises.transform.set(id, this.transformQueue.enqueue(() => this._processThumbnail(file).then(() => this._processTransform(file))));\n        }\n        return this.promises.transform.get(id);\n    }\n    /**\n     * Queues a request for a file.\n     * @param {Blob | null} blob - The file blob to upload.\n     * @param {ExtendedFile} file - The file metadata.\n     * @param {S3PutTicket} [ticket] - The S3 PUT ticket, if available.\n     * @returns {Promise<any>}\n     * @scope private\n     */\n    _queueRequest(blob, file, ticket) {\n        return this.requestQueue.enqueue(() => this._sendRequest(blob, file, ticket));\n    }\n    /**\n     * Batches the queuing of tickets for multiple files.\n     * @param {ExtendedFile[]} files - The files to queue tickets for.\n     * @returns {Deferred<S3PutTicket | undefined>[]}\n     * @scope private\n     */\n    _batchQueueTickets(files) {\n        const deferreds = [];\n        for (const file of files) {\n            const id = file.id;\n            if (!this.promises.ticket.has(id)) {\n                const deferred = (0, functions_1.deferPromise)(id);\n                deferreds.push(deferred);\n                this.promises.ticket.set(id, deferred.promise);\n            }\n        }\n        const promise = () => this._getTickets(files).then((tickets) => {\n            for (const ticket of tickets) {\n                const id = ticket.id;\n                if (this.promises.ticket.has(id)) {\n                    // Find deferred\n                    const deferred = deferreds.find((d) => d.id === id);\n                    if (deferred)\n                        deferred.resolve(ticket);\n                }\n            }\n            for (const deferred of deferreds) {\n                if (!tickets.find((t) => t.id === deferred.id)) {\n                    deferred.reject(new Error(`Error obtaining S3 PUT ticket for file id: ${deferred.id}.`));\n                }\n            }\n        });\n        this.ticketQueue.enqueue(promise);\n        return deferreds;\n    }\n    /**\n     * Monitors the progress of the upload queues and adjusts their concurrency as needed.\n     * @scope private\n     */\n    _onQueueProgress() {\n        const isS3Transfer = this._isS3TransportMode(), hasS3BatchTickets = this._hasBatchS3Tickets(), transLoad = this.transformQueue.load(true), reqLoad = this.requestQueue.load(true), tickBatchLoad = this.ticketQueue.load(true), tickLoad = hasS3BatchTickets ? tickBatchLoad * this.batchSize : tickBatchLoad, tickActive = this.ticketQueue.load(false) * (hasS3BatchTickets ? this.batchSize : 1), maxDefaultTicketConcurrency = defaults_data_1.PIPELINE_CONCURRENCY.ticket * (hasS3BatchTickets ? 1 : this.batchSize), maxTicketConcurrency = Math.round(this.settings.s3Options?.maxConcurrency || maxDefaultTicketConcurrency), maxTransformConcurrency = defaults_data_1.PIPELINE_CONCURRENCY.transform, maxRequestConcurrency = this.settings?.parallel || defaults_data_1.PIPELINE_CONCURRENCY.request, reqConcurrency = this.requestQueue.getConcurrency(), transConcurrency = this.transformQueue.getConcurrency(), tickConcurrency = this.ticketQueue.getConcurrency(), upstreamPressure = tickLoad + transLoad * 0.5, isMobile = this._isMobileDevice();\n        // Rule 1a: Transform starving, request overloaded  increase transform capacity\n        if (transLoad === 0 && reqLoad > 10) {\n            this.transformQueue.setConcurrency(Math.min(maxTransformConcurrency, transConcurrency + 1));\n        }\n        // Rule 1b: High transform load  increase concurrency (non-mobile)\n        else if (!isMobile && transLoad > 10) {\n            this.transformQueue.setConcurrency(Math.min(maxTransformConcurrency, transConcurrency + 1));\n        }\n        // Rule 2: Back off if transform load is very high and request is idle on mobile devices\n        else if (isMobile && transLoad > 20 && reqLoad < 2) {\n            this.transformQueue.setConcurrency(Math.max(1, transConcurrency - 1));\n        }\n        if (isS3Transfer) {\n            // Rule 3: Ticket queue overloaded, request underutilized  increase ticket capacity slightly\n            if (tickLoad >= 5 && reqLoad < 5) {\n                this.ticketQueue.setConcurrency(Math.min(maxTicketConcurrency, tickConcurrency + 1));\n            }\n            // Rule 4: Ticket & request queues overloaded  reduce ticket pressure\n            else if (tickLoad > 20 && reqLoad > 10) {\n                this.ticketQueue.setConcurrency(Math.max(1, tickConcurrency - 1));\n            }\n            // Rule 5. Ticket queue underutilized  increase ticket capacity slightly\n            else if (tickActive / (tickActive + tickLoad) < 0.5) {\n                this.ticketQueue.setConcurrency(Math.min(maxTicketConcurrency, tickConcurrency + 1));\n            }\n            // Rule 6. Ticket queue overutilized  reduce ticket capacity slightly\n            else if (tickActive / (tickActive + tickLoad) > 0.75) {\n                this.ticketQueue.setConcurrency(Math.max(Math.min(tickConcurrency, 2), tickConcurrency - 1));\n            }\n        }\n        // Rule 7: Upstream queues overloaded, request underutilized  increase request\n        if (upstreamPressure > 15 && reqLoad > 5) {\n            this.requestQueue.setConcurrency(Math.min(maxRequestConcurrency, reqConcurrency + 1));\n        }\n        // Rule 8: Transform queue overloaded, request starved  reduce request\n        else if (reqLoad <= 1 && transLoad > 10) {\n            this.requestQueue.setConcurrency(Math.max(1, reqConcurrency - 1));\n        }\n        // Sanity Check: ensure lower bounds\n        this.ticketQueue.setConcurrency(Math.max(1, this.ticketQueue.getConcurrency()));\n        this.transformQueue.setConcurrency(Math.max(1, this.transformQueue.getConcurrency()));\n        this.requestQueue.setConcurrency(Math.max(1, this.requestQueue.getConcurrency()));\n        // log concurrencies here, if needed\n    }\n    /**\n     * Processes thumbnail generation for a file.\n     * @param {ExtendedFile} file - The file to process.\n     * @returns {Promise<ExtendedFile>}\n     * @scope private\n     */\n    async _processThumbnail(file) {\n        return this.thumbnailService.generate(file).catch((error) => {\n            this.logger.error(`Error generating thumbnail for: ${file.name}`, error);\n            return file; // Continue processing even if thumbnail generation fails\n        });\n    }\n    /**\n     * Processes async transform operations for a file.\n     * @param {ExtendedFile} file - The file to process.\n     * @returns {Promise<ResizeResult>}\n     * @scope private\n     */\n    async _processTransform(file) {\n        const result = this.eventManager.onBeforeUpload(file);\n        if (result === false) {\n            const e = new Error(\"Upload cancelled by user.\");\n            file.status = common_1.FILE_STATUS.FAILED;\n            this.eventManager.onFileError(file, e);\n            throw e;\n        }\n        file = result instanceof extendedFile_lib_1.ExtendedFile ? result : file;\n        return this.imageTransformer.resizeToBlob(file).catch((error) => {\n            this.logger.error(\"Error during file conversion:\", error);\n            file.status = common_1.FILE_STATUS.FAILED;\n            this.eventManager.onFileError(file, error);\n            throw error;\n        });\n    }\n    /**\n     * Sends a request to upload a file.\n     * @param {ImageRequest} request - The upload request instance.\n     * @param {Blob | null} blob - The file blob to upload.\n     * @param {ExtendedFile} file - The file metadata.\n     * @returns {Promise<any>}\n     * @scope private\n     */\n    async _sendRequest(blob, file, ticket) {\n        if (!blob) {\n            file.status = common_1.FILE_STATUS.FAILED;\n            const error = new Error(`Unable to decode file: ${file.name}`);\n            this.logger.error(error);\n            throw error;\n        }\n        const request = this._makeRequest(file, ticket);\n        file.status = common_1.FILE_STATUS.UPLOADING;\n        // start progressbar\n        this.eventManager.onUploadProgress(file, 0);\n        return request\n            .send(blob, file)\n            .then((response) => {\n            this.eventManager.onFileUploadComplete(file, response);\n            return response;\n        })\n            .catch((error) => {\n            this.logger.error(\"Error during file upload:\", error);\n            file.status = common_1.FILE_STATUS.FAILED;\n            this.eventManager.onFileError(file, error);\n            throw error;\n        });\n    }\n    /**\n     * Creates a new upload request for a file.\n     * @param {ExtendedFile} file - The file to upload.\n     * @param {S3PutTicket} [ticket] - The S3 PUT ticket, if available.\n     * @returns {ImageRequest} - The created upload request.\n     */\n    _makeRequest(file, ticket) {\n        const request = this.requestFactory.create(ticket);\n        request.setFile(file);\n        return request;\n    }\n    /**\n     * Requests an S3 PUT ticket for a specific file.\n     * @param {ExtendedFile} file - The file to request a ticket for.\n     * @returns {Promise<S3PutTicket>} - A promise that resolves with the S3 PUT ticket.\n     * @scope private\n     */\n    _getTicket(file) {\n        const presignOpts = this.settings.s3Options, fileData = { [file.id]: file.name }, xhr = new XMLHttpRequest();\n        return new Promise((resolve, reject) => {\n            if (!(0, functions_1.is_plain_object)(presignOpts) || !presignOpts?.url) {\n                const error = \"S3 PUT tickets require valid S3 presign options.\";\n                this.logger.error(error);\n                return reject(new Error(error));\n            }\n            xhr.open(\"POST\", presignOpts.url, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            // Add presign params\n            const payload = { ...presignOpts };\n            delete payload.url; // Remove URL from payload\n            delete payload.maxConcurrency;\n            delete payload.batch;\n            if (!presignOpts?.fileData) {\n                payload.fileData = fileData;\n            }\n            xhr.onerror = () => {\n                const error = `Failed to fetch S3 PUT tickets: ${xhr.statusText}`;\n                this.logger.error(error, xhr.responseText);\n                reject(new Error(error));\n            };\n            xhr.onload = () => {\n                if (xhr.status === 200) {\n                    try {\n                        const response = JSON.parse(xhr.responseText);\n                        if (response) {\n                            if (response.errors) {\n                                for (const id in response.errors) {\n                                    if (id === file.id) {\n                                        const e = response.errors[id];\n                                        const error = new Error(e.message);\n                                        this.logger.error(`Error obtaining S3 PUT ticket for ${e.filename}:`, error);\n                                        return reject(error);\n                                    }\n                                }\n                            }\n                            if (response.results && (0, functions_1.is_plain_object)(response.results)) {\n                                for (const id in response.results) {\n                                    const result = response.results[id];\n                                    if (id === file.id && result.ticket) {\n                                        this.eventManager.onS3FilePresign(file, result?.media, result.ticket);\n                                        return resolve(result.ticket);\n                                    }\n                                }\n                            }\n                        }\n                        const error = `Ticket not found for ${file.name}. Skipping ticket assignment.`;\n                        this.logger.error(error);\n                        return reject(error);\n                    }\n                    catch (err) {\n                        this.logger.error(`Error processing S3 PUT ticket for ${file.name}`, err);\n                        reject(new Error(`Unable to request S3 PUT ticket for ${file.name}`));\n                    }\n                }\n                else {\n                    const error = `Failed to fetch S3 PUT ticket for ${file.name}: ${xhr.statusText}`;\n                    this.logger.error(error, xhr.responseText);\n                    reject(new Error(error));\n                }\n            };\n            xhr.send(JSON.stringify(payload));\n        });\n    }\n    /**\n     * Requests an S3 PUT ticket for collection of files.\n     * @param {ExtendedFile[]} files - The file(s) to request a ticket for.\n     * @returns {Promise<S3PutTicket[]>} - A promise that resolves with the S3 PUT tickets.\n     * @scope private\n     */\n    _getTickets(files) {\n        const presignOpts = this.settings.s3Options, fileData = files.reduce((acc, f) => {\n            acc[f.id] = f.name;\n            return acc;\n        }, {}), xhr = new XMLHttpRequest();\n        return new Promise((resolve, reject) => {\n            if (!(0, functions_1.is_plain_object)(presignOpts) || !presignOpts?.url) {\n                const error = \"S3 PUT tickets require valid S3 presign options.\";\n                this.logger.error(error);\n                return reject(new Error(error));\n            }\n            xhr.open(\"POST\", presignOpts.url, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            // Add presign params\n            const payload = { ...presignOpts };\n            delete payload.url; // Remove URL from payload\n            delete payload.maxConcurrency;\n            delete payload.batch;\n            if (!presignOpts?.fileData) {\n                payload.fileData = fileData;\n            }\n            xhr.onerror = () => {\n                const error = `Failed to fetch S3 PUT tickets: ${xhr.statusText}`;\n                this.logger.error(error, xhr.responseText);\n                reject(new Error(error));\n            };\n            xhr.onload = () => {\n                if (xhr.status === 200) {\n                    try {\n                        const tickets = [], response = JSON.parse(xhr.responseText);\n                        if (response) {\n                            if (response.errors) {\n                                for (const fileId in response.errors) {\n                                    const e = response.errors[fileId], file = files.find((f) => fileId === f.id);\n                                    if (file) {\n                                        file.status = common_1.FILE_STATUS.FAILED;\n                                        const error = new Error(e.message);\n                                        this.logger.error(`Error obtaining S3 PUT ticket for ${file.name}:`, error);\n                                        this.eventManager.onFileError(file, error);\n                                    }\n                                    else {\n                                        this.logger.error(`File not found for ${e.filename}. Skipping ticket assignment.`);\n                                        continue;\n                                    }\n                                }\n                            }\n                            if (response.results && (0, functions_1.is_plain_object)(response.results)) {\n                                for (const fileId in response.results) {\n                                    const result = response.results[fileId], file = files.find((f) => fileId === f.id);\n                                    if (file && result.ticket) {\n                                        this.eventManager.onS3FilePresign(file, result?.media, result.ticket);\n                                        tickets.push(result.ticket);\n                                    }\n                                    else {\n                                        this.logger.error(`File not found for ${result.filename}. Skipping ticket assignment.`);\n                                        continue;\n                                    }\n                                }\n                            }\n                            return resolve(tickets);\n                        }\n                        const error = `Invalid S3 PUT tickets response.`;\n                        this.logger.error(error, response);\n                        return reject(new Error(error));\n                    }\n                    catch (err) {\n                        const error = `Error processing S3 PUT ticket for ${files.length} files.`;\n                        this.logger.error(error, err);\n                        reject(new Error(error));\n                    }\n                }\n                else {\n                    const error = `Error processing S3 PUT ticket for ${files.length} files: ${xhr.statusText}`;\n                    this.logger.error(error, xhr.responseText);\n                    reject(new Error(error));\n                }\n            };\n            xhr.send(JSON.stringify(payload));\n        });\n    }\n    /**\n     * Normalizes the batch size value.\n     * @param {boolean | number | undefined} batch - The batch size value to normalize.\n     * @returns {number} - The normalized batch size.\n     * @scope private\n     */\n    _normalizeBatchSize(batch) {\n        if (batch === undefined || batch === false)\n            return 1;\n        if (batch === true)\n            return defaults_data_1.S3_TICKET_BATCH_SIZE;\n        if (Number.isFinite(batch) && batch > 0)\n            return Math.round(batch);\n        return 1;\n    }\n    /**\n     * Checks if the current upload is using S3 as the transport mode.\n     * @returns {boolean} - True if S3 is being used, false otherwise.\n     * @scope private\n     */\n    _isS3TransportMode() {\n        return this.settings.transportMode === \"S3\";\n    }\n    /**\n     * Checks if the current upload has batch tickets.\n     * @returns {boolean} - True if batch tickets are available, false otherwise.\n     * @scope private\n     */\n    _hasBatchS3Tickets() {\n        return this._isS3TransportMode() && this.batchSize > 1;\n    }\n    /**\n     * Checks if the current device is a mobile device.\n     * @returns {boolean} - True if the device is mobile, false otherwise.\n     * @scope private\n     */\n    _isMobileDevice() {\n        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(feature_lib_1.Env.agent);\n    }\n}\nexports.UploadPipeline = UploadPipeline;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImagePostRequest = void 0;\nconst common_1 = require(\"../types/common\");\nconst imageRequest_lib_1 = require(\"./imageRequest.lib\");\n/**\n * ImagePostRequest\n * Concrete transport that preserves the original XHR POST behavior:\n * - Multipart: FormData + file chunk as `media`, plus `multipart_params`\n * - Non-multipart: binary body with `Content-Type: application/octet-stream`\n * - Uses `settings.uploadUrl`\n *\n * Only transport is defined here; chunking, retries, and progress come from the base class.\n */\nclass ImagePostRequest extends imageRequest_lib_1.ImageRequest {\n    /**\n     * Passthrough constructor.\n     * @param {ImageUploaderSettings} settings\n     */\n    constructor(settings) {\n        super(settings);\n    }\n    /**\n     * Cancels the current upload request\n     * @scope public\n     */\n    cancel() {\n        this.offset = 0;\n        super.cancel();\n    }\n    /**\n     * Send the upload request via fetch or XMLHttpRequest\n     * @param {Blob | File} blob - Blob or original File object\n     * @param {ExtendedFile} file - The file object wrapper to upload\n     * @returns {Promise}\n     */\n    send(blob, file) {\n        const that = this;\n        let chunkSize = this.settings.chunkSize;\n        file.loaded = file.loaded || 0; // Ensure file.loaded is defined\n        file.percent = file.percent || 0; // Ensure file.percent is defined\n        file.status = file.status || common_1.FILE_STATUS.QUEUED; // Ensure file.status is defined\n        this.active = true; // Mark the request as active\n        this.file = file; // Store the file reference\n        this.blob = blob; // Get the source blob or file\n        return new Promise((resolve, reject) => {\n            // bail if no blob\n            if (!blob || blob.size === 0) {\n                reject(new Error(\"Invalid format provided for upload.\"));\n                return;\n            }\n            this.logger.debug(\"Starting upload for file\", file.name, \"of size\", blob.size);\n            // make sure we start at a predictable offset\n            if (file.loaded) {\n                that.offset = file.loaded = chunkSize ? chunkSize * Math.floor(file.loaded / chunkSize) : 0;\n            }\n            // Start the upload process\n            file.status = common_1.FILE_STATUS.UPLOADING;\n            this._uploadNextChunk().then(resolve, reject).catch(reject);\n        });\n    }\n    /**\n     * Prepares the next chunk of the file for upload.\n     * If the file is smaller than the chunk size, it prepares the entire file.\n     * If the file is larger than the chunk size, it prepares the file in chunks.\n     * @returns {Promise} - A promise that resolves when the next chunk is ready to be uploaded.\n     * @protected\n     */\n    _uploadNextChunk() {\n        return new Promise((resolve, reject) => {\n            const chunkSize = this.settings.chunkSize;\n            const blob = this.blob;\n            const args = {};\n            let chunkBlob;\n            let curChunkSize;\n            // make sure that file wasn't cancelled and upload is not stopped in general\n            if (!this.file || this.file.status !== common_1.FILE_STATUS.UPLOADING || !this.active) {\n                return;\n            }\n            // send additional 'name' parameter only if required\n            args.name = this.file.target_name || this.file.name;\n            if (chunkSize && blob.size > chunkSize) {\n                // blob will be of type string if it was loaded in memory\n                curChunkSize = Math.min(chunkSize, blob.size - this.offset);\n                chunkBlob = blob.slice(this.offset, this.offset + curChunkSize);\n            }\n            else {\n                curChunkSize = blob.size;\n                chunkBlob = blob;\n            }\n            // If chunking is enabled add corresponding args, no matter if file is bigger than chunk or smaller\n            if (chunkSize) {\n                // Setup query string arguments\n                if (this.settings.sendChunkNumber) {\n                    args.chunk = Math.ceil(this.offset / chunkSize);\n                    args.chunks = Math.ceil(blob.size / chunkSize);\n                }\n                else {\n                    // keep support for experimental chunk format, just in case\n                    args.offset = this.offset;\n                    args.total = blob.size;\n                }\n            }\n            if (this.eventManager.onBeforeChunkUpload(this.file, args, chunkBlob, this.offset) !== false) {\n                this.logger.debug(\"Starting upload for chunk\", args.chunk || 1, \"of file\", this.file.name, \"at offset\", this.offset);\n                this._uploadChunk(args, chunkBlob, curChunkSize).then(resolve, reject).catch(reject);\n            }\n            else {\n                reject(new Error(\"Upload cancelled by user\"));\n            }\n        });\n    }\n    /**\n     * Uploads a chunk of the file.\n     * This function is called recursively until the entire file is uploaded.\n     * @param {Object} args - Additional arguments for the upload.\n     * @param {Blob} chunkBlob - The blob representing the current chunk of the file.\n     * @param {number} curChunkSize - The size of the current chunk being uploaded.\n     * @returns {Promise} - A promise that resolves when the chunk is uploaded successfully or rejects on error.\n     * @protected\n     */\n    _uploadChunk(args, chunkBlob, curChunkSize) {\n        return new Promise((resolve, reject) => {\n            const that = this;\n            const xhr = new XMLHttpRequest();\n            const file = this.file;\n            this.xhr = xhr;\n            // Do we have upload progress support\n            if (xhr.upload) {\n                xhr.upload.onprogress = function (e) {\n                    file.loaded = Math.min(file.size, e.loaded);\n                    that._onFileProgress(file);\n                };\n            }\n            xhr.onload = function () {\n                // check if upload made itself through\n                if (xhr.status < 200 || xhr.status >= 400) {\n                    return that._handleError(xhr.responseText || \"HTTP Error: \" + xhr.status).then(resolve, reject);\n                }\n                that.retries = that.settings.maxRetries || 0; // reset the counter\n                // Handle chunk response\n                if (curChunkSize < that.blob.size) {\n                    // chunkBlob.destroy();\n                    that.offset += curChunkSize;\n                    file.loaded = Math.min(that.offset, that.blob.size);\n                    that.eventManager.onChunkUploadComplete(file, {\n                        offset: file.loaded,\n                        total: that.blob.size,\n                        response: xhr.responseText,\n                        status: xhr.status,\n                        responseHeaders: xhr.getAllResponseHeaders(),\n                    });\n                    // stock Android browser doesn't fire upload progress events, but in chunking mode we can fake them\n                    if (that.browser === \"Android Browser\") {\n                        // doesn't harm in general, but is not required anywhere else\n                        that._onFileProgress(file);\n                    }\n                }\n                else {\n                    file.loaded = file.size;\n                }\n                chunkBlob = null; // Free memory\n                // Check if file is uploaded\n                if (!that.offset || that.offset >= that.blob.size) {\n                    // If file was modified, destroy the copy\n                    if (file.size != file.origSize) {\n                        that.logger.debug(\"File size changed, destroying blob copy for\", file.name);\n                        that.blob = null;\n                    }\n                    that._onFileProgress(file);\n                    file.status = common_1.FILE_STATUS.DONE;\n                    file.completeTimestamp = +new Date();\n                    try {\n                        const response = JSON.parse(xhr.responseText);\n                        resolve(response);\n                    }\n                    catch (e) {\n                        const errorMessage = `Failed to parse response: ${xhr.responseText}`;\n                        that.logger.error(errorMessage, e);\n                        reject(new Error(errorMessage));\n                    }\n                }\n                else {\n                    // Still chunks left\n                    return that._delay(that._uploadNextChunk.bind(that), 1).then(resolve, reject); // run detached, otherwise event handlers interfere\n                }\n            };\n            xhr.onerror = function () {\n                that._handleError(`Network error: ${xhr.statusText}`).then(resolve, reject);\n            };\n            xhr.onloadend = function () {\n                that.xhr = null;\n            };\n            xhr.onabort = function () {\n                that._handleError(\"abort\").then(resolve, reject);\n            };\n            that.logger.debug(\"Starting upload for file\", file.name, \"at offset\", that.offset);\n            this._sendRequest(args, chunkBlob);\n        });\n    }\n    /**\n     * Sends the upload request using XMLHttpRequest.\n     * @param {Object} args - Additional arguments for the upload.\n     * @param {Blob} chunkBlob - The blob to upload.\n     * @protected\n     */\n    _sendRequest(args, chunkBlob) {\n        const xhr = this.xhr || new XMLHttpRequest();\n        const formData = new FormData();\n        const fileName = this.file.name;\n        let url = this.settings.uploadUrl;\n        this.xhr = xhr;\n        // Build multipart request\n        if (this.settings.multipart) {\n            xhr.open(\"POST\", url, true);\n            // Set custom headers\n            // xhr.setRequestHeader(name, value);\n            // Add multipart params\n            const multipartParams = this.settings.multipart_params;\n            if (multipartParams && typeof multipartParams === \"object\") {\n                for (const key in multipartParams) {\n                    if (Object.prototype.hasOwnProperty.call(multipartParams, key)) {\n                        formData.append(key, multipartParams[key]);\n                    }\n                }\n            }\n            // Add file and send it\n            formData.append(\"media\", chunkBlob, fileName);\n            xhr.send(formData);\n        }\n        else {\n            // if no multipart, send as binary stream\n            url = this._buildUrl(this.settings.uploadUrl, $.extend({}, args, this.settings.multipart_params));\n            xhr.open(\"POST\", url, true);\n            // Set custom headers\n            // xhr.setRequestHeader(name, value);\n            // do not set Content-Type, if it was defined previously (see #1203)\n            xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\"); // Binary stream header\n            xhr.send(chunkBlob);\n        }\n    }\n    /**\n     * Handles errors during the upload process.\n     * @param {string} error - The error message or response text.\n     * @returns {Promise} - A promise that resolves to retry the upload or rejects with\n     * @protected\n     * @throws {Error} Throws an error if the maximum number of retries is exceeded.\n     */\n    _handleError(error) {\n        let errorMessage;\n        if (typeof error === \"undefined\") {\n            errorMessage = \"HTTP Error: \";\n            if (this?.xhr) {\n                errorMessage += this.xhr.status;\n            }\n            else {\n                errorMessage += \"undefined\";\n            }\n        }\n        else if (error === \"abort\") {\n            errorMessage = \"Upload manually aborted\";\n            this.retries = 0;\n        }\n        else {\n            errorMessage = error;\n        }\n        if (this.retries-- > 0) {\n            if (this?.file) {\n                this.logger.debug(`Retrying upload for ${this.file.name}.`, `Attempt #${(this.settings.maxRetries || 0) - this.retries}`);\n            }\n            return this._delay(this._uploadNextChunk.bind(this), 1000);\n        }\n        else {\n            if (this?.file)\n                this.file.loaded = this.offset; // reset all progress\n            return Promise.reject(this._toError(errorMessage));\n        }\n    }\n}\nexports.ImagePostRequest = ImagePostRequest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOptions = exports.S3_OPTIONS_DEFAULTS = exports.S3_TICKET_BATCH_SIZE = exports.PIPELINE_CONCURRENCY = exports.THUMB_SIZE_DEFAULTS = exports.RESIZE_DEFAULTS = void 0;\nconst feature_lib_1 = require(\"../../libs/feature.lib\");\n/**\n * RESIZE_DEFAULTS\n * @type {Object.<string, number|boolean>}\n * @property {number} quality - Default quality for resized images.\n * @property {boolean} preserveHeaders - Whether to preserve image headers during resizing.\n * @property {boolean} crop - Whether to crop the image during resizing.\n */\nexports.RESIZE_DEFAULTS = {\n    quality: 0.9,\n    preserveHeaders: false,\n    crop: false,\n};\n/**\n * THUMB_SIZE_DEFAULTS\n * @type {Object.<string, number>}\n * @property {number} width - Default width for thumbnails.\n * @property {number} height - Default height for thumbnails.\n */\nexports.THUMB_SIZE_DEFAULTS = {\n    width: 200,\n    height: 200,\n};\n/**\n * PIPELINE_CONCURRENCY\n * @type {Object.<string, number>}\n * @property {number} ticket - Concurrency level for ticket requests.\n * @property {number} transform - Concurrency level for transform requests.\n * @property {number} request - Concurrency level for upload requests.\n */\nexports.PIPELINE_CONCURRENCY = {\n    ticket: 4,\n    transform: feature_lib_1.Env.hardwareConcurrency,\n    request: 6,\n};\n/**\n * Ticket batch size for processing uploads.\n * @constant\n * @type {number}\n * @default 5\n */\nexports.S3_TICKET_BATCH_SIZE = 5;\n/**\n * Default options for S3 presigned requests.\n * @constant\n * @type {S3PresignOptions}\n */\nexports.S3_OPTIONS_DEFAULTS = {\n    url: \"\",\n    listing_id: 0,\n    lot: 0,\n    dbSave: 1,\n    prepend: 0,\n    processed: 0,\n    maxConcurrency: exports.PIPELINE_CONCURRENCY.ticket,\n    batch: exports.S3_TICKET_BATCH_SIZE,\n};\n/**\n * defaultOptions\n * @type {ImageUploaderSettings}\n * @description Default settings for the image uploader.\n */\nexports.defaultOptions = {\n    resize: undefined,\n    filters: {},\n    dragDropEnabled: true,\n    maxRetries: 3,\n    maxWidthOrHeight: 1400, // 0 means no limit\n    uploadUrl: \"\",\n    browseButton: undefined, // Optional selector for browse button\n    dropElement: undefined, // Optional selector for drop zone element\n    multipart: true,\n    multipart_params: {},\n    parallel: 1,\n    chunkSize: 0,\n    sendChunkNumber: false,\n    thumbnails: false,\n    transportMode: \"S3\",\n    s3Options: undefined, // Optional S3 presign options\n    // Callback functions\n    initialize: function () { },\n    onBeforeQueue: function (files) {\n        return files;\n    },\n    onS3FilePresign: function (file, media, ticket) {\n        (void file, media, ticket);\n    },\n    onBeforeChunkUpload: function (file, args, chunk, offset) {\n        (void file, args, chunk, offset);\n    },\n    onBeforeUpload: function (file) {\n        return file;\n    },\n    onPreviewThumbnail: function (file, $canvas) {\n        (void file, $canvas);\n    },\n    onUploadProgress: function (file, progress, stats) {\n        (void file, progress, stats);\n    },\n    onChunkUploadComplete: function (file, response) {\n        (void file, response);\n    },\n    onFileUploadComplete: function (file, response) {\n        (void file, response);\n    },\n    onAllUploadsComplete: function (files) {\n        void files;\n    },\n    onFileError: function (file, error) {\n        (void file, error);\n    },\n    onError: function (error) {\n        void error;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.maps = void 0;\n/**\n * Maps for browser, device, and OS versions\n * @type {Object}\n * @property {Object} browser - Maps for browser versions\n * @property {Object} device - Maps for device models and vendors\n * @property {Object} os - Maps for OS versions\n */\nexports.maps = {\n    browser: {\n        oldsafari: {\n            major: {\n                1: [\"/8\", \"/1\", \"/3\"],\n                2: \"/4\",\n                \"?\": \"/\",\n            },\n            version: {\n                \"1.0\": \"/8\",\n                1.2: \"/1\",\n                1.3: \"/3\",\n                \"2.0\": \"/412\",\n                \"2.0.2\": \"/416\",\n                \"2.0.3\": \"/417\",\n                \"2.0.4\": \"/419\",\n                \"?\": \"/\",\n            },\n        },\n    },\n    device: {\n        sprint: {\n            model: {\n                \"Evo Shift 4G\": \"7373KT\",\n            },\n            vendor: {\n                HTC: \"APA\",\n                Sprint: \"Sprint\",\n            },\n        },\n    },\n    os: {\n        windows: {\n            version: {\n                ME: \"4.90\",\n                \"NT 3.11\": \"NT3.51\",\n                \"NT 4.0\": \"NT4.0\",\n                2000: \"NT 5.0\",\n                XP: [\"NT 5.1\", \"NT 5.2\"],\n                Vista: \"NT 6.0\",\n                7: \"NT 6.1\",\n                8: \"NT 6.2\",\n                8.1: \"NT 6.3\",\n                RT: \"ARM\",\n            },\n        },\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThumbnailService = exports.AVATAR_URL = exports.THUMB_SIZE_DEFAULTS = void 0;\n/// <reference types=\"jquery\" />\nconst console_logger_1 = require(\"../console.logger\");\nconst eventManager_lib_1 = require(\"./eventManager.lib\");\nconst extendedImage_lib_1 = require(\"./extendedImage.lib\");\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst queueManager_lib_1 = require(\"./queueManager.lib\");\n/**\n * THUMB_SIZE_DEFAULTS\n * @type {Dimensional}\n * @property {number} width - Default width for thumbnails.\n * @property {number} height - Default height for thumbnails.\n */\nexports.THUMB_SIZE_DEFAULTS = {\n    width: 200,\n    height: 200,\n};\n/**\n * AVATAR_URL\n * @type {string}\n */\nexports.AVATAR_URL = \"https://ui-avatars.com/api/\";\n/**\n * ThumbnailService class for generating thumbnails for uploaded files\n * @class ThumbnailService\n * @property {ImageUploaderSettings} settings - Configuration settings for the uploader\n * @property {Logger} logger - Logger instance for logging messages\n * @property {EventManager} eventManager - Event manager for handling events\n * @property {QueueManager} queueManager - Queue manager for managing tasks\n * @property {Emitter<ExtendedFile>} emitter - Emitter for managing internal event listener\n */\nclass ThumbnailService {\n    /**\n     * Creates a new ThumbnailService instance\n     * @param {ImageUploaderSettings} settings - Configuration settings for the uploader\n     * @constructor\n     */\n    constructor(settings) {\n        this.settings = settings;\n        this.logger = console_logger_1.Logger.getInstance();\n        this.eventManager = eventManager_lib_1.EventManager.getInstance(settings);\n        this.queueManager = new queueManager_lib_1.QueueManager(this.settings.parallel || 1);\n    }\n    /**\n     * Generate upload thumbnails for multiple files\n     * @param {ExtendedFile[]} files - Array of files to generate thumbnails for\n     * @return {Promise}\n     * @scope public\n     */\n    async generateAll(files) {\n        if (this.settings.thumbnails) {\n            this.logger.debug(`Generating thumbnails for ${files.length} files:`);\n            const promises = await Promise.allSettled(files.map((file) => this.queueManager.enqueue(() => this.generate(file))));\n            this.logger.debug(\"Thumbnail generation completed.\");\n            return promises.map((result, i) => (result.status === \"fulfilled\" ? result.value : files[i]));\n        }\n        else {\n            this.logger.debug(\"Thumbnails are not enabled. Skipping thumbnail generation.\");\n            return Promise.resolve(files); // No thumbnails to generate\n        }\n    }\n    /**\n     * Generate a thumbnail for a single file\n     * @param {ExtendedFile} file - The file to generate a thumbnail for\n     * @returns {Promise<ExtendedFile>}\n     * @scope public\n     */\n    generate(file) {\n        try {\n            return this._preload(file).catch((e) => {\n                this.logger.warn(`Skipping thumbnail for ${file.name}:`, e.message);\n                return file; // Return the file even if thumbnail generation fails\n            });\n        }\n        catch (error) {\n            this.logger.warn(`Failed to generate thumbnail for ${file.name}:`, error);\n            return Promise.resolve(file); // Continue processing pipeline regardless\n        }\n    }\n    /**\n     * Preload thumbnail for the file\n     * @param {ExtendedFile} file - The file to preload thumbnail for\n     * @returns {Promise<ExtendedFile>}\n     * @scope private\n     */\n    _preload(file) {\n        return new Promise((resolve, reject) => {\n            if (!this.settings?.thumbnails) {\n                this.logger.debug(\"Thumbnails are not enabled or container is not specified.\");\n                resolve(file);\n                return;\n            }\n            try {\n                this._process(file)\n                    .then(resolve)\n                    .catch(() => {\n                    this.logger.warn(`No thumbnail available for file ${file.name}. Generating fallback avatar.`);\n                    this._avatar(file).then(resolve).catch(reject);\n                });\n            }\n            catch (error) {\n                this.logger.warn(`Error preloading thumbnail for file ${file.name}. Falling back to avatar:`, error);\n                // synchronous fallback to avatar generation\n                try {\n                    this._avatar(file)\n                        .then(resolve)\n                        .catch((e) => {\n                        this.logger.warn(`Failed to generate avatar for file ${file.name}:`, e.message);\n                        reject(e);\n                    });\n                }\n                catch (error_avatar) {\n                    this.logger.warn(`Failed to generate avatar for file ${file.name}:`, error_avatar);\n                    reject(error_avatar);\n                }\n            }\n        });\n    }\n    /**\n     * Process the file and generate a thumbnail\n     * @param {ExtendedFile} file - The file to process\n     * @returns {Promise<ExtendedFile>}\n     * @scope private\n     */\n    _process(file) {\n        return new Promise((resolve, reject) => {\n            const that = this, img = new extendedImage_lib_1.ExtendedImage(true), $thumb = $(`<div id=\"${file.id}\" class=\"file_thumb thumb_preview\"></div>`), { width, height } = this._resolution();\n            img.on(\"load\", function () {\n                that.logger.debug(`Generating thumbnail for file ${file.name} (${img.width}x${img.height})`);\n                img.embed($thumb[0], {\n                    width,\n                    height,\n                    crop: true,\n                    fit: false,\n                    preserveHeaders: false,\n                });\n            });\n            img.bind(\"embedded error\", function (e) {\n                const $canvas = $thumb.find(\"canvas\");\n                if (e.type === \"error\" || !$canvas.length) {\n                    const err = `Error generating thumbnail for file ${file.name}`;\n                    that.logger.error(err, e);\n                    img.destroy();\n                    if (e.target && e.target !== img)\n                        e.target.destroy();\n                    reject(new Error(err));\n                }\n                else {\n                    $canvas.addClass(\"thumb_preview_canvas\");\n                    that.eventManager.onPreviewThumbnail(file, $canvas);\n                    img.destroy();\n                    if (e.target && e.target !== img)\n                        e.target.destroy();\n                    resolve(file);\n                }\n            });\n            img.load(file).catch(reject);\n        });\n    }\n    /**\n     * Fallback avatar generation for files without thumbnails\n     * @param {ExtendedFile} file - The file to generate avatar for\n     * @returns {Promise<ExtendedFile>}\n     * @throws {Error} - If fetch or blob fail to execute correctly.\n     * @scope private\n     */\n    async _avatar(file) {\n        const ext = (((file && file.name) || \"\").split(\".\").pop() || \"\").toUpperCase(), url = new URL(exports.AVATAR_URL), { width, height } = this._resolution();\n        url.searchParams.append(\"name\", `.${ext}`);\n        url.searchParams.append(\"length\", \"4\");\n        url.searchParams.append(\"background\", \"random\");\n        url.searchParams.append(\"size\", `${Math.min(width || 0, height || 0)}`);\n        url.searchParams.append(\"font-size\", \"0.3\");\n        this.logger.debug(`Generating fallback avatar for file ${file.name} with URL: ${url}`);\n        let response;\n        try {\n            response = await fetch(url);\n        }\n        catch (e) {\n            const message = `Failed to load fallback image for ${file.name}`;\n            this.logger.error(message, e);\n            throw new Error(message);\n        }\n        try {\n            const blob = await response.blob();\n            const fallbackFile = new extendedFile_lib_1.ExtendedFile(blob);\n            fallbackFile.name = `${file.name}_fallback-avatar.${ext}`;\n            return this._process(fallbackFile);\n        }\n        catch (e) {\n            const message = `Failed to convert fallback image for ${file.name}`;\n            this.logger.error(message, e);\n            throw new Error(message);\n        }\n    }\n    /**\n     * Get the resolution settings for thumbnails\n     * @returns {SemiDimensional} - Returns the width and height for thumbnails\n     * @private\n     */\n    _resolution() {\n        const isDimensional = (o) => o !== null && [\"object\", \"function\"].includes(typeof o) && (\"width\" in o || \"height\" in o), custom = typeof this.settings.thumbnails === \"object\" ? this.settings.thumbnails.size : undefined, options = isDimensional(custom) ? custom : exports.THUMB_SIZE_DEFAULTS, resolution = {};\n        if (options.width)\n            resolution.width = options.width;\n        if (options.height)\n            resolution.height = options.height;\n        return resolution;\n    }\n}\nexports.ThumbnailService = ThumbnailService;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtendedFile = void 0;\nconst common_1 = require(\"../types/common\");\n/**\n * ExtendedFile class\n * @class ExtendedFile\n * @description A wrapper for the File object that adds custom properties and methods.\n */\nclass ExtendedFile {\n    /**\n     * Creates an instance of ExtendedFile.\n     * @param {File | Blob} file - The file or blob to wrap.\n     * @param {ExtendedFileOptions} [options] - Optional parameters.\n     */\n    constructor(file, options = {}) {\n        if (!(file instanceof File || file instanceof Blob)) {\n            throw new TypeError(\"Expected a File or Blob instance.\");\n        }\n        this.id = options.id || crypto.randomUUID(); // Fallback to some unique ID logic\n        this.name = file instanceof File ? file.name : options.name || `file_${this.id}.${this._toExt(file.type)}`;\n        this.target_name = options.name || this.name;\n        this._file = file instanceof File ? file : new File([file], this.name, { type: file.type });\n        this.lastModifiedDate = file instanceof File ? new Date(file.lastModified) : new Date();\n        this.loaded = 0;\n        this.percent = 0;\n        this.status = common_1.FILE_STATUS.QUEUED;\n        this.createdDate = new Date();\n        this.origSize = file.size;\n        this.completeTimestamp = undefined;\n    }\n    /**\n     * Returns the original File object.\n     * @returns {File} The original File object wrapped by this instance.\n     */\n    getSource() {\n        return this._file;\n    }\n    /**\n     * The size of the file in bytes.\n     * @returns {number} The size of the file in bytes.\n     */\n    get size() {\n        return this._file.size;\n    }\n    /**\n     * The MIME type of the file.\n     * @returns {string} The MIME type of the file.\n     */\n    get type() {\n        return this._file.type;\n    }\n    /**\n     * Slices the file and returns a new File object.\n     * @param {number} start - The start byte position.\n     * @param {number} end - The end byte position.\n     * @param {string} [contentType] - The MIME type to use for the new File object.\n     * @returns {Blob} A new Blob object representing the sliced portion.\n     */\n    slice(start, end, contentType) {\n        return this._file.slice(start, end, contentType);\n    }\n    /**\n     * Converts a MIME type to a file extension.\n     * @param {string} mimeType - The MIME type to convert.\n     * @returns {string} The file extension corresponding to the MIME type.\n     */\n    _toExt(mimeType) {\n        return mimeType.split(\"/\")[1] || \"bin\"; // Default to 'bin' if no extension found\n    }\n}\nexports.ExtendedFile = ExtendedFile;\nExtendedFile.FILE_STATUS = common_1.FILE_STATUS;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageS3Request = void 0;\nconst common_1 = require(\"../types/common\");\nconst imageRequest_lib_1 = require(\"./imageRequest.lib\");\n/**\n * ImageS3Request\n * Concrete transport for S3-style single-request uploads (no chunking).\n */\nclass ImageS3Request extends imageRequest_lib_1.ImageRequest {\n    /**\n     * Passthrough constructor.\n     * @param {ImageUploaderSettings} settings\n     * @param {S3PutTicket} ticket\n     */\n    constructor(settings, ticket) {\n        super(settings);\n        this.ticket = ticket;\n    }\n    /**\n     * Starts a single-shot S3 PUT upload (no chunking).\n     * Keeps the same method name/signature as the base class.\n     * @param {Blob | File} blob - Entire Blob or File to upload in one request.\n     * @param {ExtendedFile} file - The file wrapper metadata.\n     * @returns {Promise<any>}\n     * @scope public\n     */\n    send(blob, file) {\n        file.loaded = file.loaded || 0; // Ensure file.loaded is defined\n        file.percent = file.percent || 0; // Ensure file.percent is defined\n        file.status = file.status || common_1.FILE_STATUS.QUEUED; // Ensure file.status is defined\n        this.active = true; // Mark the request as active\n        this.file = file; // Store the file reference\n        this.blob = blob; // Get the source blob or file\n        return new Promise((resolve, reject) => {\n            // bail if no blob\n            if (!blob || blob.size === 0) {\n                reject(new Error(\"Invalid format provided for upload.\"));\n                return;\n            }\n            this.logger.debug(\"Starting upload for file\", file.name, \"of size\", blob.size);\n            // Start the upload process\n            file.status = common_1.FILE_STATUS.UPLOADING;\n            this._preTransport(blob).then(resolve, reject).catch(reject);\n        });\n    }\n    /**\n     * Prepares the transport layer for the upload.\n     * @param {Blob} blob - The Blob to upload.\n     * @returns {Promise<any>}\n     * @protected\n     */\n    _preTransport(blob) {\n        const that = this;\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            const file = this.file;\n            this.xhr = xhr;\n            // Do we have upload progress support\n            if (xhr.upload) {\n                xhr.upload.onprogress = function (e) {\n                    file.loaded = Math.min(file.size, e.loaded);\n                    that._onFileProgress(file);\n                };\n            }\n            xhr.onload = function () {\n                // check if upload made itself through\n                if (xhr.status < 200 || xhr.status >= 400) {\n                    return that._handleError(xhr.responseText || \"HTTP Error: \" + xhr.status).then(resolve, reject);\n                }\n                that.retries = that.settings.maxRetries || 0; // reset the counter\n                file.loaded = file.size;\n                // If file was modified, destroy the copy\n                if (file.size != file.origSize) {\n                    that.logger.debug(\"File size changed, destroying blob copy for\", file.name);\n                    that.blob = null;\n                }\n                that._onFileProgress(file);\n                file.status = common_1.FILE_STATUS.DONE;\n                file.completeTimestamp = +new Date();\n                const rawHeaders = xhr\n                    .getAllResponseHeaders()\n                    .trim()\n                    .split(/[\\r\\n]+/);\n                const headers = {};\n                rawHeaders.forEach((line) => {\n                    const parts = line.split(\": \");\n                    const header = parts.shift();\n                    const value = parts.join(\": \");\n                    if (header)\n                        headers[header.toLowerCase()] = value;\n                });\n                resolve(headers);\n            };\n            xhr.onerror = function () {\n                that._handleError(`Network error: ${xhr.statusText}`).then(resolve, reject);\n            };\n            xhr.onloadend = function () {\n                that.xhr = null;\n            };\n            xhr.onabort = function () {\n                that._handleError(\"abort\").then(resolve, reject);\n            };\n            that.logger.debug(\"Starting upload for file\", file.name, \"at offset\", that.offset);\n            this._sendRequest({}, blob); // for consistency with chunked uploads\n        });\n    }\n    /**\n     * Sends the upload request using XMLHttpRequest PUT to S3 (pre)signed URL.\n     * Although S3 here is non-chunked, the hook is preserved for parity with the base contract.\n     * @param {Object} args - Optional args (e.g., headers/context).\n     * @param {Blob} chunkBlob - In this class, this will be the entire blob.\n     * @protected\n     */\n    _sendRequest(args, blob) {\n        const xhr = this.xhr || new XMLHttpRequest();\n        const ticket = this.ticket;\n        xhr.open(\"PUT\", ticket.url, true);\n        // Send EXACTLY the signed headers\n        Object.entries(ticket.headers || {}).forEach(([k, v]) => {\n            if (v != null && v !== \"\")\n                xhr.setRequestHeader(k, String(v));\n        });\n        xhr.send(blob);\n    }\n    /**\n     * Handles errors during the upload process.\n     * @param {string} error - The error message or response text.\n     * @returns {Promise} - A promise that resolves to retry the upload or rejects with\n     * @protected\n     * @throws {Error} Throws an error if the maximum number of retries is exceeded.\n     */\n    _handleError(error) {\n        let errorMessage;\n        if (typeof error === \"undefined\") {\n            errorMessage = \"HTTP Error: \";\n            if (this?.xhr) {\n                errorMessage += this.xhr.status;\n            }\n            else {\n                errorMessage += \"undefined\";\n            }\n        }\n        else if (error === \"abort\") {\n            errorMessage = \"Upload manually aborted\";\n            this.retries = 0;\n        }\n        else {\n            errorMessage = error;\n        }\n        if (this.retries-- > 0) {\n            if (this?.file) {\n                this.logger.debug(`Retrying upload for ${this.file.name}.`, `Attempt #${(this.settings.maxRetries || 0) - this.retries}`);\n            }\n            return this._delay(() => this._preTransport(this.blob), 1000);\n        }\n        else {\n            if (this?.file)\n                this.file.loaded = 0; // reset all progress\n            return Promise.reject(this._toError(errorMessage));\n        }\n    }\n}\nexports.ImageS3Request = ImageS3Request;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MimeReader = void 0;\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst magic_data_json_1 = __importDefault(require(\"../data/mime/magic.data.json\"));\n/**\n * MimeReader class for detecting MIME types based on file headers.\n * This class reads the first 64 bytes of a file and matches them against known magic numbers\n * to determine the MIME type.\n * @class MimeReader\n * @constructor\n * @scope public\n */\nclass MimeReader {\n    /**\n     * Detect the MIME type of a file by reading its first 64 bytes.\n     * @param {ExtendedFile | SourcedFile | File | Blob} file - The file or blob to detect the MIME type\n     * @returns {Promise<string>} - A promise that resolves with the detected MIME type\n     * @scope public\n     */\n    static async detectMime(file) {\n        return new Promise((resolve, reject) => {\n            const blob = (file instanceof extendedFile_lib_1.ExtendedFile || _a._isSourcedFile(file) ? file.getSource() : file).slice(0, 64); // only read first 64 bytes\n            const reader = new FileReader();\n            reader.onloadend = (e) => {\n                const result = (e.target && e.target.result) || undefined;\n                if (result instanceof ArrayBuffer) {\n                    const bytes = new Uint8Array(result);\n                    const mime = this._matchMagic(bytes);\n                    resolve(mime);\n                }\n                else {\n                    reject(new Error(\"Unexpected result type from FileReader\"));\n                }\n            };\n            reader.onerror = () => reject(reader.error);\n            reader.readAsArrayBuffer(blob);\n        });\n    }\n    // --- Utility Methods ---\n    /**\n     * Convert an array of bytes to a hexadecimal string.\n     * @param {Uint8Array} bytes - The byte array to convert\n     * @returns {string} - The hexadecimal representation of the byte array\n     * @scope private\n     * @static\n     */\n    static _bytesToHex(bytes) {\n        return Array.from(bytes)\n            .map((b) => b.toString(16).padStart(2, \"0\"))\n            .join(\"\");\n    }\n    /**\n     * Checks if a file is a SourcedFile.\n     * @param {any} file - The file to check.\n     * @returns {file is SourcedFile} - True if the file is a SourcedFile, false otherwise.\n     * @scope private\n     * @static\n     */\n    static _isSourcedFile(file) {\n        return file && typeof file.getSource === \"function\";\n    }\n    /**\n     * Match the magic numbers in the header bytes against known MIME types.\n     * @param {Uint8Array} headerBytes - The first 64 bytes of the file\n     * @returns {string} - The detected MIME type or \"unknown\" if no match is found\n     * @scope private\n     * @static\n     */\n    static _matchMagic(headerBytes) {\n        const hex = this._bytesToHex(headerBytes);\n        const magic = _a.MAGIC_DATA;\n        /**\n         * @param {MagicTuple} entry - The magic number entry to parse\n         * @returns {string|null} - The MIME type if matched, otherwise null\n         * @private\n         */\n        function _test(prefix, entry) {\n            const [match, offset, , mime] = entry;\n            if (!match)\n                return mime;\n            const offsetHex = hex.slice(prefix.length + offset * 2, prefix.length + offset * 2 + match.length);\n            return offsetHex === match.toLowerCase() ? mime : null;\n        }\n        let mime = null;\n        for (const type in magic) {\n            switch (type) {\n                case \"extension_only\":\n                case \"footers\":\n                    // Skip extension-only and footer\n                    break;\n                case \"multi_part\":\n                    // Check for multi-part magic numbers\n                    for (const prefix in magic[type]) {\n                        if (hex.startsWith(prefix.toLowerCase())) {\n                            for (const entry of magic[type][prefix]) {\n                                // Check if the magic number matches\n                                if ((mime = _test(prefix, entry)))\n                                    return mime;\n                            }\n                        }\n                    }\n                    break;\n                case \"headers\":\n                    // Check for header magic numbers\n                    for (const entry of magic[type]) {\n                        if ((mime = _test(\"\", entry)))\n                            return mime;\n                    }\n                    break;\n            }\n        }\n        return \"unknown\";\n    }\n    /**\n     * Converts the magic data from JSON format to a structured format.\n     * @param {any} data - The raw magic data to convert\n     * @returns {MagicData} - The converted magic data in the expected format\n     * @throws {Error} - If the data is not in the expected format\n     * @scope private\n     * @static\n     */\n    static _toMagic(data) {\n        /**\n         * Converts an array to a MagicTuple.\n         * @param {Array} arr - The array to convert\n         * @returns {MagicTuple} - The converted MagicTuple\n         * @throws {Error} - If the array does not have the correct shape\n         */\n        function __toMagicTuple(arr) {\n            if (arr.length !== 5)\n                throw new Error(\"Incorrect shape: magic data\");\n            const [match, offset, extension, mime, description] = arr;\n            return [String(match), Number(offset), String(extension), String(mime), String(description)];\n        }\n        if (data == null || typeof data !== \"object\") {\n            throw new Error(\"Invalid value(s): magic data\");\n        }\n        const result = {\n            extension_only: [],\n            multi_part: {},\n            footers: [],\n            headers: [],\n        };\n        for (const key of Object.keys(result)) {\n            const value = data[key];\n            switch (key) {\n                case \"multi_part\":\n                    if (typeof value === \"object\" && value !== null) {\n                        // e.g. multi_part: an object mapping signatures to arrays of tuples\n                        const nested = {};\n                        for (const innerKey of Object.keys(value)) {\n                            const arr = value[innerKey];\n                            if (!Array.isArray(arr)) {\n                                throw new Error(`Expected array for multi_part.${innerKey}`);\n                            }\n                            nested[innerKey] = arr.map(__toMagicTuple);\n                        }\n                        result[key] = nested; // multi_part special-case\n                    }\n                    break;\n                case \"extension_only\":\n                case \"footers\":\n                case \"headers\":\n                    if (Array.isArray(value)) {\n                        // value is an array of raw tuples\n                        result[key] = value.map(__toMagicTuple);\n                    }\n                    break;\n                default:\n                    throw new Error(`Unexpected shape for key \"${key}\"`);\n            }\n        }\n        return result;\n    }\n}\nexports.MimeReader = MimeReader;\n_a = MimeReader;\n/**\n * Magic data for MIME type detection.\n * This is a mapping of magic numbers to their corresponding MIME types.\n * @type {MagicData}\n * @scope private\n * @see https://github.com/cdgriffith/puremagic/blob/master/puremagic/magic_data.json\n * @see https://en.wikipedia.org/wiki/List_of_file_signatures\n */\nMimeReader.MAGIC_DATA = _a._toMagic(magic_data_json_1.default);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UploadController = void 0;\n/// <reference types=\"jquery\" />\nconst console_logger_1 = require(\"../console.logger\");\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst fileProcessor_lib_1 = require(\"./fileProcessor.lib\");\nconst eventManager_lib_1 = require(\"./eventManager.lib\");\nconst registry_1 = require(\"../plugins/registry\");\nconst imageReader_lib_1 = require(\"./imageReader.lib\");\nconst uploadPipeline_lib_1 = require(\"./uploadPipeline.lib\");\n/**\n * UploadController class for managing the upload process\n * @class UploadController\n * @param {ImageUploaderSettings} settings - Configuration settings for the uploader\n * @property {Logger} logger - Logger instance for logging messages\n * @property {FileProcessor} fileProcessor - Processes files before upload\n * @property {QueueManager} queueManager - Manages the file upload queue\n * @property {EventManager} eventManager - Event bus for managing events\n * @property {UploadPipeline} pipeline - Manages the upload pipeline\n */\nclass UploadController {\n    /**\n     * Creates an instance of UploadController.\n     * @param {ImageUploaderSettings} settings - The settings for the image uploader.\n     * @scope public\n     * @constructor\n     */\n    constructor(settings) {\n        this.settings = settings;\n        this.logger = console_logger_1.Logger.getInstance();\n        this.fileProcessor = new fileProcessor_lib_1.FileProcessor(this.settings);\n        this.eventManager = eventManager_lib_1.EventManager.getInstance(this.settings);\n        this.pipeline = new uploadPipeline_lib_1.UploadPipeline(this.settings);\n    }\n    /**\n     * Initializes the upload controller.\n     * @returns {void}\n     * @description Sets up the file processor to observe filters and registers plugins for supported MIME types,\n     * and initializes the event manager to handle various upload events.\n     * This method should be called before starting the upload process.\n     * @scope public\n     */\n    initialize() {\n        this.fileProcessor.observeFilters();\n        this._registerPlugins();\n        this.eventManager.onInitialize();\n    }\n    /**\n     * Starts the upload process by orchestrating the file processing and upload pipeline.\n     * @param {File[] | FileList} files\n     * @scope public\n     */\n    filesAdded(files) {\n        this.fileProcessor\n            .applyFilters(files)\n            .then((filtered) => this._onFilesFiltered(filtered))\n            .then((accepted) => this.fileProcessor.initialize(accepted.map((result) => result.file)))\n            .then((_files) => this._onBeforeQueue(_files))\n            .then((_files) => this.pipeline.process(_files).then(() => this.handleAllUploadsComplete(_files)))\n            .catch((error) => {\n            this.logger.error(\"Error processing upload(s):\", error);\n            this.eventManager.onError(error);\n            this.handleAllUploadsComplete([]);\n        });\n    }\n    /**\n     * Calls the onBeforeQueue handler before files are added to the upload queue.\n     * @param {ExtendedFile[]} files - The files to be queued.\n     * @returns {Promise<ExtendedFile[]>} - Modified or original files to be queued, or an error if cancelled by user.\n     * @scope private\n     */\n    async _onBeforeQueue(files) {\n        const result = this.eventManager.onBeforeQueue(files);\n        if (result === false) {\n            const error = \"Upload cancelled by user before queue processing.\";\n            this.logger.debug(error);\n            throw new Error(error);\n        }\n        else if (Array.isArray(result)) {\n            return result.filter((f) => f instanceof extendedFile_lib_1.ExtendedFile);\n        }\n        return files;\n    }\n    /**\n     * Handles results of file filtering.\n     * @param {ImageFilterResult} filterResult - The result of the filtering process.\n     * @returns {Promise<FileFilterResult[]>} - The accepted files or an error if all files were rejected.\n     * @scope private\n     */\n    async _onFilesFiltered(filterResult) {\n        const { accepted, rejected } = filterResult;\n        if (rejected.length > 0) {\n            for (const reject of rejected) {\n                const { file, reason } = reject;\n                this.eventManager.onFileError(file, reason || \"File rejected by filters\");\n            }\n        }\n        if (accepted.length === 0) {\n            const error = \"No files accepted for upload. All files were rejected by filters.\";\n            this.logger.warn(error);\n            throw new Error(error);\n        }\n        return accepted;\n    }\n    /**\n     * Handle all uploads complete event handler\n     * @param {ExtendedFile[]} files - Array of files that were processed\n     * @scope private\n     */\n    handleAllUploadsComplete(files) {\n        this.eventManager.onAllUploadsComplete(files);\n        try {\n            this.reset();\n        }\n        catch (error) {\n            this.logger.debug(\"Failed to reset uploadController instance:\", error);\n        }\n    }\n    /**\n     * Resets the upload controller pipeline\n     * @returns {void}\n     * @scope public\n     */\n    reset() {\n        if (this.pipeline.isActive()) {\n            this.pipeline.reset();\n            this.eventManager.onError(\"Upload manually cancelled\");\n        }\n        this.logger.debug(\"UploadController reset.\");\n    }\n    /**\n     * Destroys the upload controller instance\n     * @returns {void}\n     * @scope public\n     */\n    destroy() {\n        this.reset();\n        // Nullify references to help garbage collection\n        this.fileProcessor = null;\n        this.eventManager = null;\n        this.settings = null;\n        this.logger = null;\n        this.pipeline = null;\n        console.debug(\"UploadController destroyed.\");\n    }\n    /**\n     * Register plugins for supported MIME types\n     * @returns {void}\n     * @scope private\n     */\n    _registerPlugins() {\n        const selectedMimes = this.fileProcessor.getSupportedMimes();\n        const plugins = registry_1.PluginRegistry.getPlugins();\n        if (plugins) {\n            if (selectedMimes && selectedMimes.size > 0) {\n                for (const mime of selectedMimes) {\n                    if (plugins[mime]) {\n                        this.logger.debug(`Registering plugin for MIME type: ${mime}`);\n                        imageReader_lib_1.ImageReader.registerPlugin(mime, plugins[mime]);\n                    }\n                }\n            }\n            if (plugins[\"image/*\"]) {\n                imageReader_lib_1.ImageReader.registerPlugin(\"image/*\", plugins[\"image/*\"]);\n            }\n        }\n        else {\n            this.logger.warn(\"No plugins found for non web-native MIME types.\");\n        }\n    }\n}\nexports.UploadController = UploadController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UAParser = void 0;\n// /src/libs/features/uaparser.lib.ts\nconst mapper_lib_1 = require(\"./mapper.lib\");\nconst regex_data_1 = require(\"../../data/features/regex.data\");\nconst common_data_1 = require(\"../../data/features/common.data\");\n/**\n * User-Agent Parser\n * @description This class provides methods to parse the User-Agent string and retrieve information about the browser, engine, and operating system.\n * It uses regular expressions defined in the `browsers`, `oses`, and `engines` data files to extract the relevant information.\n * @class UAParser\n */\nclass UAParser {\n    /**\n     * Creates an instance of UAParser.\n     * @param {string} [uastring] - The User-Agent string to parse.\n     * @description If no User-Agent string is provided, it defaults to the browser's User-Agent string.\n     * If the User-Agent string is not available, it defaults to an empty string.\n     * @constructor\n     */\n    constructor(uastring) {\n        this._ua =\n            typeof uastring === common_data_1.UNDEF_TYPE\n                ? window.navigator && window.navigator.userAgent\n                    ? window.navigator.userAgent\n                    : common_data_1.EMPTY\n                : uastring;\n    }\n    /**\n     * Get or set the User-Agent string\n     * @returns {string}\n     */\n    get ua() {\n        return this._ua;\n    }\n    /**\n     * Set the User-Agent string\n     * @param {string} uastring - The User-Agent string to set\n     */\n    set ua(uastring) {\n        this._ua = uastring;\n    }\n    /**\n     * Get Browser information\n     * @returns {UAParserBrowserType}\n     */\n    getBrowser() {\n        return mapper_lib_1.mapper.rgx.call(this, ...regex_data_1.browsers);\n    }\n    /**\n     * Get Engine information\n     * @returns {UAParserEngineType}\n     */\n    getEngine() {\n        return mapper_lib_1.mapper.rgx.call(this, ...regex_data_1.engines);\n    }\n    /**\n     * Get OS information\n     * @returns {UAParserOSType}\n     */\n    getOS() {\n        return mapper_lib_1.mapper.rgx.call(this, ...regex_data_1.oses);\n    }\n    /**\n     * Get Environment information\n     * @description This method aggregates the User-Agent, Browser, Engine, and OS information into a single object.\n     * @returns {UAParserEnvironment}\n     */\n    getResult() {\n        return {\n            ua: this._ua,\n            browser: this.getBrowser(),\n            engine: this.getEngine(),\n            os: this.getOS(),\n        };\n    }\n}\nexports.UAParser = UAParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MIME_TYPES = exports.FILE_STATUS = void 0;\n// --- Enums ---\n/**\n * FILE_STATUS\n * @enum {number}\n * This enum represents the various statuses a file can have during the upload process.\n * @property {number} QUEUED - File is queued for upload\n * @property {number} UPLOADING - File is being uploaded\n * @property {number} FAILED - File has failed to be uploaded\n * @property {number} DONE - File has been uploaded successfully\n */\nvar FILE_STATUS;\n(function (FILE_STATUS) {\n    FILE_STATUS[FILE_STATUS[\"QUEUED\"] = 1] = \"QUEUED\";\n    FILE_STATUS[FILE_STATUS[\"UPLOADING\"] = 2] = \"UPLOADING\";\n    FILE_STATUS[FILE_STATUS[\"FAILED\"] = 4] = \"FAILED\";\n    FILE_STATUS[FILE_STATUS[\"DONE\"] = 5] = \"DONE\";\n    FILE_STATUS[FILE_STATUS[\"CANCELED\"] = 6] = \"CANCELED\";\n})(FILE_STATUS || (exports.FILE_STATUS = FILE_STATUS = {}));\n// --- Constants ---\n/**\n * MIME_TYPES\n * @type {Object.<string, string>}\n */\nexports.MIME_TYPES = {\n    jpeg: \"image/jpeg\",\n    jpg: \"image/jpeg\",\n    jfif: \"image/jpeg\",\n    png: \"image/png\",\n    webp: \"image/webp\",\n    heic: \"image/heic\",\n    heif: \"image/heif\",\n    gif: \"image/gif\",\n    bmp: \"image/bmp\",\n    avif: \"image/avif\",\n    tiff: \"image/tiff\",\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pageData = void 0;\nexports.pageData = window[\"pageData\"];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageRequest = void 0;\nconst eventManager_lib_1 = require(\"./eventManager.lib\");\nconst console_logger_1 = require(\"../console.logger\");\nconst feature_lib_1 = require(\"./feature.lib\");\nconst functions_1 = require(\"../utils/functions\");\n/**\n * Abstract base class for handling file upload requests\n * @param {ImageUploaderSettings} settings - Configuration settings for the uploader\n * @class ImageRequest\n */\nclass ImageRequest {\n    /**\n     * Abstract constructor for ImageRequest.\n     * @param {ImageUploaderSettings} settings - The settings for the image uploader.\n     * @constructor\n     * @scope public\n     */\n    constructor(settings) {\n        this.settings = settings;\n        this.eventManager = eventManager_lib_1.EventManager.getInstance(settings);\n        this.logger = console_logger_1.Logger.getInstance();\n        this.browser = feature_lib_1.Env.browser || \"Unknown\";\n        this.retries = this.settings.maxRetries || 0;\n        this.offset = 0;\n        this.active = false;\n        this.canceled = false;\n        this.xhr = null;\n        this.file = null;\n        this.blob = null;\n    }\n    /**\n     * Cancels the current upload request\n     * @scope public\n     */\n    cancel() {\n        this.canceled = true;\n        this.active = false;\n        this.retries = 0;\n        this.file = null;\n        this.blob = null;\n        if (this.xhr && this.xhr.readyState !== XMLHttpRequest.DONE) {\n            try {\n                this.xhr?.abort();\n            }\n            catch (error) {\n                this.logger.debug(\"Error aborting xhr:\", error);\n            }\n            finally {\n                this.xhr = null;\n            }\n        }\n    }\n    /**\n     * Send the upload request via fetch or XMLHttpRequest\n     * @param {Blob | File} blob - Blob or original File object\n     * @param {ExtendedFile} file - The file object wrapper to upload\n     * @returns {Promise}\n     * @scope public\n     */\n    send(blob, file) {\n        return Promise.resolve();\n    }\n    /**\n     * Gets the file associated with the request.\n     * @returns {ExtendedFile | null} - The file object or null if not set.\n     * @scope public\n     */\n    getFile() {\n        return this.file;\n    }\n    /**\n     * Sets the file associated with the request.\n     * @param {ExtendedFile} file - The file object to associate with the request.\n     * @scope public\n     */\n    setFile(file) {\n        this.file = file;\n    }\n    /**\n     * Sends the upload request using XMLHttpRequest.\n     * @param {Object} args - Additional arguments for the upload.\n     * @param {Blob} chunkBlob - The blob to upload.\n     * @protected\n     */\n    _sendRequest(args, chunkBlob) { }\n    /**\n     * Handles errors during the upload process.\n     * @param {string} error - The error message or response text.\n     * @returns {Promise} - A promise that resolves to retry the upload or rejects with\n     * @protected\n     * @throws {Error} Throws an error if the maximum number of retries is exceeded.\n     */\n    _handleError(error) {\n        return Promise.resolve();\n    }\n    /**\n     * Handles the file upload progress event.\n     * @param {ExtendedFile} file - The file being uploaded.\n     * @protected\n     */\n    _onFileProgress(file) {\n        file.percent = file.size > 0 ? Math.ceil((file.loaded / file.size) * 100) : 100;\n        this.eventManager.onUploadProgress(file, file.percent);\n    }\n    /**\n     * Builds a full url out of a base URL and an object with items to append as query string items.\n     *\n     * @method buildUrl\n     * @static\n     * @param {String} url Base URL to append query string items to.\n     * @param {Object} items Name/value object to serialize as a querystring.\n     * @return {String} String with url + serialized query string items.\n     * @protected\n     */\n    _buildUrl(url, items) {\n        let query = \"\";\n        if (items && typeof items === \"object\") {\n            for (const name in items) {\n                if (Object.prototype.hasOwnProperty.call(items, name)) {\n                    const value = items[name];\n                    query += (query ? \"&\" : \"\") + encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n                }\n            }\n        }\n        if (query) {\n            url += (url.indexOf(\"?\") > 0 ? \"&\" : \"?\") + query;\n        }\n        return url;\n    }\n    /**\n     * Delays the execution of a function by a specified number of milliseconds.\n     * @param {Function} fn - The function to delay.\n     * @param {number} ms - The number of milliseconds to delay.\n     * @returns {Promise} - A promise that resolves with the result of the function after the delay.\n     * @protected\n     */\n    _delay(fn, ms) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                try {\n                    const result = fn();\n                    if (result && typeof result.then === \"function\") {\n                        result.then(resolve, reject).catch(reject);\n                    }\n                    else {\n                        resolve(result);\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }, ms);\n        });\n    }\n    /**\n     * Converts an error object or string into a standardized Error instance.\n     * @param {string | Object} error - The error to convert.\n     * @returns {Error} - A standardized Error instance with details.\n     * @protected\n     */\n    _toError(error) {\n        // Normalize error into an actual Error instance\n        let obj;\n        try {\n            const parsed = typeof error === \"string\" ? JSON.parse(error) : error;\n            if (error instanceof Error || (parsed && parsed instanceof Error)) {\n                obj = error;\n            }\n            else {\n                obj = this.__parseError(parsed);\n                if ((0, functions_1.is_plain_object)(parsed) || Array.isArray(parsed)) {\n                    // @ts-ignore\n                    obj.details = parsed;\n                }\n            }\n        }\n        catch (_) {\n            let fallback = \"[Unknown error]\";\n            try {\n                fallback = typeof error === \"string\" ? error : String(error);\n            }\n            catch (_) {\n                fallback = \"[Unparsable error]\";\n            }\n            obj = new Error(fallback);\n        }\n        return obj;\n    }\n    /**\n     * Parses the error object or string into a standardized Error instance.\n     * @param {string | Object} error - The error to parse.\n     * @returns {Error} - A standardized Error instance with details.\n     * @protected\n     */\n    __parseError(error) {\n        let parsed;\n        try {\n            if (typeof error?.toString === \"function\" && Object.prototype.hasOwnProperty.call(error, \"toString\")) {\n                parsed = error.toString();\n            }\n            else if (Reflect.has(error, \"errorMessage\")) {\n                parsed = error.errorMessage;\n            }\n            else if (Reflect.has(error, \"message\")) {\n                parsed = error.message;\n            }\n            else if ((0, functions_1.is_plain_object)(error)) {\n                parsed = JSON.stringify(error);\n            }\n            else {\n                parsed = String(error);\n            }\n        }\n        catch (_) {\n            parsed = error;\n        }\n        return new Error(parsed);\n    }\n}\nexports.ImageRequest = ImageRequest;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapper = void 0;\nconst common_data_1 = require(\"../../data/features/common.data\");\n/**\n * Utility functions for string manipulation\n * @type {Object}\n * @property {Function} has - Checks if a string contains another string, case-insensitive\n * @property {Function} lowerize - Converts a string to lowercase\n * @scope private\n */\nconst util = {\n    has: (str1, str2) => str2.toLowerCase().includes(str1.toLowerCase()),\n    lowerize: (str) => str.toLowerCase(),\n};\n/**\n * Mapper for regular expressions and string maps\n * @property {Function} rgx - Maps regular expressions to properties.\n * @property {Function} str - Maps a string against a map of known values.\n * @type {Object}\n */\nexports.mapper = {\n    /**\n     * Maps regular expressions to properties\n     * @param {...UAParserRegexList} _args - Pairs of regular expressions and properties\n     * @returns {Uploader.Feature.UAParserComponent} - An object containing the matched properties\n     * @scope private\n     */\n    rgx: function (..._args) {\n        let result = {}, _arguments = arguments;\n        for (let i = 0, j, k, p, q, matches = null, match, args = _arguments; i < args.length; i += 2) {\n            const regex = args[i], props = args[i + 1];\n            if (Object.keys(result).length === 0) {\n                for (p in props) {\n                    q = props[p];\n                    result[Array.isArray(q) && q.length ? q[0] : q] = undefined;\n                }\n            }\n            for (j = k = 0; j < regex.length; j++) {\n                matches = regex[j].exec(this.ua);\n                if (matches) {\n                    for (p = 0; p < props.length; p++) {\n                        match = matches[++k];\n                        q = props[p];\n                        if (Array.isArray(q) && q.length) {\n                            const [key, arg1, arg2, arg3] = q;\n                            if (q.length === 2) {\n                                result[key] =\n                                    typeof arg1 === common_data_1.FUNC_TYPE ? arg1.call(this, match) : arg1;\n                            }\n                            else if (q.length === 3) {\n                                result[key] = match\n                                    ? typeof arg1 === common_data_1.FUNC_TYPE\n                                        ? arg1.call(this, match, arg2)\n                                        : match.replace(arg1, arg2)\n                                    : undefined;\n                            }\n                            else if (q.length === 4) {\n                                result[key] = match\n                                    ? arg3.call(this, match.replace(arg1, arg2))\n                                    : undefined;\n                            }\n                        }\n                        else {\n                            result[q] = match || undefined;\n                        }\n                    }\n                    break;\n                }\n            }\n            if (matches)\n                break;\n        }\n        return result;\n    },\n    /**\n     * Maps a string against a map of known values\n     * @param {string} str - The string to map\n     * @param {Record<string, any>} [map] - The map of known values\n     * @returns {string} - The mapped value or the original string if not found\n     * @scope private\n     */\n    str: (str, map) => {\n        map = map || {};\n        for (const key in map) {\n            const val = map[key];\n            if (typeof val === common_data_1.OBJ_TYPE && Array.isArray(val) && val.length) {\n                for (const sub of val) {\n                    if (util.has(sub, str))\n                        return key === common_data_1.UNKNOWN ? undefined : key;\n                }\n            }\n            else if (typeof val === \"string\" && util.has(val, str)) {\n                return key === common_data_1.UNKNOWN ? undefined : key;\n            }\n        }\n        return str;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtendedImage = exports.IMAGE_EVENT_TYPES = void 0;\nconst console_logger_1 = require(\"../console.logger\");\nconst feature_lib_1 = require(\"./feature.lib\");\nconst feature_lib_2 = require(\"./feature.lib\");\nconst imageReader_lib_1 = require(\"./imageReader.lib\");\nconst functions_1 = require(\"../utils/functions\");\n// --- Enums ---\n/**\n * IMAGE_EVENT_TYPES\n * @enum {string}\n * This enum represents the different event types for image processing.\n */\nvar IMAGE_EVENT_TYPES;\n(function (IMAGE_EVENT_TYPES) {\n    IMAGE_EVENT_TYPES[\"LOAD\"] = \"load\";\n    IMAGE_EVENT_TYPES[\"ERROR\"] = \"error\";\n    IMAGE_EVENT_TYPES[\"RESIZE\"] = \"resize\";\n    IMAGE_EVENT_TYPES[\"EMBEDDED\"] = \"embedded\";\n    IMAGE_EVENT_TYPES[\"RUNTIME_ERROR\"] = \"runtimeerror\";\n})(IMAGE_EVENT_TYPES || (exports.IMAGE_EVENT_TYPES = IMAGE_EVENT_TYPES = {}));\n// --- Classes ---\n/**\n * ExtendedImage class\n * @class ExtendedImage\n * @param {boolean} [useCache=false] - Whether to use caching for the image.\n * @description This class extends the basic Image functionality\n * to include additional features such as resizing, EXIF handling, and event management.\n * It provides methods to load images from various sources, resize them, and manage metadata.\n * @constructor\n * @scope public\n */\nclass ExtendedImage {\n    constructor(useCache) {\n        this.logger = console_logger_1.Logger.getInstance();\n        this.useCache = typeof useCache === \"undefined\" ? false : !!useCache;\n        this.image = new Image();\n        this.blob = null;\n        this.canvas = document.createElement(\"canvas\");\n        this._events = {};\n        this.width = 0;\n        this.height = 0;\n        this.type = \"\";\n        this.crop = false;\n        this.fit = true;\n        this.preserveHeaders = true;\n        this.quality = 0.9;\n        this.meta = {\n            orientation: 1,\n            rawEXIF: undefined,\n            exif: null,\n            thumbnail: undefined,\n        };\n    }\n    /**\n     * Load an image from various input formats.\n     * @param {ImageInput} input - The image input to load.\n     * @param {ImageLoadOptions} [options] - Options for loading the image.\n     * @returns {Promise<ExtendedImage>} - A promise that resolves with the loaded image.\n     * @description This method supports loading images from strings, File objects, or Blob objects.\n     * It decodes the image data and returns an ExtendedImage instance.\n     */\n    load(input, options) {\n        if (this.useCache) {\n            return this._hydrate(input, options);\n        }\n        return this._decode(input, options);\n    }\n    /**\n     * Creates a deep clone of the ExtendedImage instance.\n     * @returns {Promise<ExtendedImage>} A promise that resolves to a cloned ExtendedImage instance.\n     * @throws {Error} If the image is not loaded or if cloning fails.\n     */\n    async clone() {\n        const clone = new ExtendedImage();\n        // Clone canvas contents\n        let clonedCanvas = null;\n        if (this.canvas instanceof HTMLCanvasElement) {\n            clonedCanvas = this._cloneCanvas(this.canvas);\n            clone.canvas = clonedCanvas;\n        }\n        clone.width = this.width;\n        clone.height = this.height;\n        clone.type = this.type;\n        clone.preserveHeaders = this.preserveHeaders;\n        clone.quality = this.quality;\n        clone.crop = this.crop;\n        clone.fit = this.fit;\n        try {\n            // Clone the blob and convert to image\n            if (this.blob instanceof Blob) {\n                clone.blob = this.blob.slice(0, this.blob.size, this.blob.type);\n            }\n            else if (clone.canvas instanceof HTMLCanvasElement) {\n                clone.blob = await this._canvasToBlob(clonedCanvas, this.quality, this.preserveHeaders);\n            }\n            clone.image = await this._blobToImage(clone.blob);\n            // clone metadata\n            clone.meta = {};\n            for (const key in this.meta) {\n                const val = this.meta[key];\n                if (val instanceof Blob) {\n                    clone.meta[key] = val.slice(0, val.size, val.type);\n                }\n                else if (typeof val === \"object\" && val !== null) {\n                    clone.meta[key] = (0, functions_1.deep_clone)(val);\n                }\n                else {\n                    clone.meta[key] = val;\n                }\n            }\n            return clone;\n        }\n        catch (err) {\n            throw new Error(\"Failed to clone instance: \" + err.message);\n        }\n    }\n    /**\n     * Downsizes the image to the specified width and height.\n     * @param {...*} args - The arguments for downsize.\n     * @param {number} [width] - The target width of the image.\n     * @param {number} [height] - The target height of the image.\n     * @param {string} [type] - The MIME type of the resized image.\n     * @param {number} [quality=0.9] - The quality of the resized image (0 to 1).\n     * @param {boolean} [crop=true] - Whether to crop the image to fit the specified dimensions.\n     * @param {boolean} [fit=true] - Whether to apply a scaling constraint and preserve the aspect ratio.\n     * @param {boolean} [multipass=true] - Whether to use multipass resizing for better quality.\n     * @param {boolean} [preserveHeaders=true] - Whether to preserve image headers during resizing.\n     * @param {boolean} [includeBlob=false] - Whether to include the resized image as a Blob.\n     * @returns {void}\n     */\n    downsize(...args) {\n        let opts;\n        if (typeof args[0] === \"object\") {\n            opts = Object.assign({\n                width: 0,\n                height: 0,\n                type: \"image/jpeg\",\n                quality: 0.9,\n                crop: false,\n                fit: true,\n                multipass: true,\n                preserveHeaders: true,\n                includeBlob: false,\n            }, args[0]);\n        }\n        else {\n            opts = {\n                width: args[0],\n                height: args[1],\n                type: typeof args[2] !== \"undefined\" ? args[2] : \"image/jpeg\",\n                quality: typeof args[3] !== \"undefined\" ? args[3] : 0.9,\n                crop: typeof args[4] !== \"undefined\" ? args[4] : false,\n                fit: typeof args[5] !== \"undefined\" ? args[5] : true,\n                multipass: typeof args[6] !== \"undefined\" ? args[6] : true,\n                preserveHeaders: typeof args[7] !== \"undefined\" ? args[7] : true,\n                includeBlob: typeof args[8] !== \"undefined\" ? args[8] : false,\n            };\n        }\n        this.resize(opts);\n    }\n    /**\n     * Resizes the image to a new resolution.\n     * @param {ImageResizeOptions} options - The options for resizing.\n     * @description This method resizes the image to the specified dimensions.\n     * It can crop the image based on the aspect ratio, and it can preserve EXIF headers.\n     * It optionally uses multi-pass scaling for better quality.\n     */\n    resize({ width = 0, height = 0, type = \"image/jpeg\", quality = 0.9, crop = false, fit = true, multipass = true, preserveHeaders = true, includeBlob = false, }) {\n        if (!document.createElement(\"canvas\").getContext) {\n            throw new Error(\"Resizing by Canvas not supported in this environment.\");\n        }\n        else if (!width && !height) {\n            throw new TypeError(\"Width or height must be numeric non-zero values.\");\n        }\n        const srcCanvas = this._imageToCanvas(this.image);\n        quality = quality > 1 ? quality / 100 : quality <= 0 ? 0.9 : quality;\n        if (!width || !height || !crop) {\n            ({ width, height } = this._calcMaxDimensions(srcCanvas, Math.max(width, height)));\n        }\n        if (crop) {\n            this.canvas = this._cropCanvas(srcCanvas, { width, height, fit, quality, multipass });\n        }\n        else {\n            if (multipass) {\n                this.canvas = this._multiPassScale(srcCanvas, width, height);\n            }\n            else {\n                this.canvas = this._scale(srcCanvas, width, height);\n            }\n        }\n        this.width = this.canvas.width;\n        this.height = this.canvas.height;\n        this.preserveHeaders = preserveHeaders;\n        this.quality = quality;\n        this.type = type;\n        this.crop = crop;\n        this.fit = fit;\n        if (includeBlob) {\n            this._canvasToBlob(this.canvas, this.quality, this.preserveHeaders)\n                .then(async (blob) => {\n                const cacheKey = await this._cacheKey(blob);\n                this.blob = blob;\n                if (this.useCache && !this._hasCache(cacheKey)) {\n                    this.logger.debug(`Saving resized `, `${this.canvas.width}x${this.canvas.height}`, `image to cache with key:`, `${cacheKey}`);\n                    this._saveCache(cacheKey);\n                }\n                this._trigger(\"resize\", { target: this, type: IMAGE_EVENT_TYPES.RESIZE });\n            })\n                .catch((err) => {\n                this.logger.error(\"_canvasToBlob failed during resize:\", err);\n                this.blob = null;\n                this._trigger(\"error\", { error: err, type: IMAGE_EVENT_TYPES.ERROR, target: this });\n            });\n        }\n        else {\n            this.blob = null;\n            this._trigger(\"resize\", { target: this, type: IMAGE_EVENT_TYPES.RESIZE });\n        }\n    }\n    /**\n     * Embeds a visual representation of the image into the specified DOM element.\n     * @param {HTMLElement} el - The DOM element to embed the image into.\n     * @param {ImageEmbedOptions} [options = {}] - Options for embedding the image.\n     * @throws {TypeError|Error} If the element is not a valid DOM element or if the image is not loaded.\n     * @description This method embeds a canvas element into the specified DOM element.\n     */\n    async embed(el, options = {}) {\n        try {\n            const element = typeof el === \"string\" ? document.querySelector(el) : el;\n            if (!(element instanceof HTMLElement)) {\n                throw new TypeError(\"Invalid DOM element provided.\");\n            }\n            if (!this.width || !this.height) {\n                throw new Error(\"Image not loaded.\");\n            }\n            const { width = 0, height = 0, type = this.type || \"image/jpeg\", quality = this.quality || 0.9, crop = false, fit = true, preserveHeaders = false, } = options;\n            // Create a copy of the image and resize it\n            const thumb = (await this._getMetaThumbnail()) || (await this.clone());\n            thumb.downsize({\n                width,\n                height,\n                type,\n                quality,\n                crop,\n                fit,\n                multipass: false,\n                preserveHeaders,\n                includeBlob: false,\n            });\n            // Use canvas if supported\n            if (feature_lib_1.Capabilities.canSupportCanvas()) {\n                const canvas = thumb.getCanvas();\n                element.innerHTML = \"\"; // clear existing\n                element.appendChild(canvas);\n                this._trigger(\"embedded\", { target: thumb, type: IMAGE_EVENT_TYPES.EMBEDDED });\n                return;\n            }\n            else {\n                return this._trigger(\"error\", {\n                    error: new Error(\"Canvas not supported\"),\n                    type: IMAGE_EVENT_TYPES.ERROR,\n                    target: this,\n                });\n            }\n        }\n        catch (err) {\n            this._trigger(\"error\", { error: err, type: IMAGE_EVENT_TYPES.ERROR, target: this });\n        }\n    }\n    /**\n     * Destroys the image and releases resources.\n     * @scope public\n     */\n    destroy() {\n        if (this.image) {\n            if (this.image.onload)\n                this.image.onload = null;\n            if (this.image.onerror)\n                this.image.onerror = null;\n            URL.revokeObjectURL(this.image.src);\n        }\n        this._releaseCanvas(this.canvas);\n        this.canvas = null;\n        this.image = null;\n        this.blob = null;\n        this.meta = null;\n        this._events = {};\n    }\n    /**\n     * Get the image metadata.\n     * @returns {ImageMetadata} - The metadata of the image.\n     * @description This method returns the metadata associated with the image,\n     * including EXIF data, orientation, and thumbnail if available.\n     */\n    getMetadata() {\n        return this.meta;\n    }\n    /**\n     * Get the canvas element.\n     * @returns {HTMLCanvasElement} - The canvas element.\n     */\n    getCanvas() {\n        return this.canvas;\n    }\n    /**\n     * Get the image as a Data URL.\n     * @param {number} [quality=0.9] - The quality of the image (0 to 1).\n     * @returns {string} - The Data URL of the image.\n     * @description This method returns the image as a Data URL in the specified format and quality.\n     * It falls back to PNG format if the specified type is not supported.\n     * @throws {Error} If the canvas cannot be converted to the specified type.\n     */\n    getAsDataURL(quality) {\n        const qualityValue = typeof quality !== \"undefined\" ? quality : this.quality;\n        const normalizedQuality = qualityValue > 1 ? qualityValue / 100 : qualityValue <= 0 ? 0.9 : qualityValue;\n        if (this.canvas instanceof HTMLCanvasElement) {\n            try {\n                return this.canvas.toDataURL(this.type, normalizedQuality);\n            }\n            catch (e) {\n                this.logger.debug(`Fallback to PNG: ${e.message}`);\n                return this.canvas.toDataURL(\"image/png\");\n            }\n        }\n        throw new Error(\"Canvas not available. Image not loaded or processed.\");\n    }\n    /**\n     * Get the image as a Blob.\n     * @param {number} [quality=0.9] - The quality of the image (0 to 1).\n     * @param {boolean} [preserveHeaders=false] - Whether to preserve EXIF headers.\n     * @returns {Promise<Blob>} - A promise that resolves with the Blob of the image.\n     * @description Returns a promise containing the Blob representation of the image.\n     */\n    getAsBlob(quality, preserveHeaders) {\n        const that = this;\n        const preserveHeadersValue = typeof preserveHeaders === \"undefined\" ? false : !!preserveHeaders;\n        const qualityValue = typeof quality !== \"undefined\" ? quality : this.quality;\n        const normalizedQuality = qualityValue > 1 ? qualityValue / 100 : qualityValue <= 0 ? 0.9 : qualityValue;\n        return new Promise((resolve, reject) => {\n            if (this.blob) {\n                resolve(this.blob);\n            }\n            else if (this.canvas instanceof HTMLCanvasElement) {\n                that\n                    ._canvasToBlob(that.canvas, normalizedQuality, preserveHeadersValue)\n                    .then((blob) => {\n                    that.blob = blob;\n                    resolve(blob);\n                })\n                    .catch(reject);\n            }\n            else {\n                reject(new Error(\"Unable to retrieve Blob. Image not loaded or processed.\"));\n            }\n        });\n    }\n    // --- Utility Methods ---\n    /**\n     * Decodes image data from string, File, or Blob and returns a promise with the decoded image.\n     * @param {ImageInput} input - The image to decode.\n     * @param {ImageLoadOptions} [options] - Options for loading the image.\n     * @returns {Promise<ExtendedImage>} - A promise that resolves with the decoded image.\n     * @scope private\n     */\n    _decode(input, options) {\n        return new Promise((resolve, reject) => {\n            imageReader_lib_1.ImageReader.decode(input, options)\n                .then(async ({ canvas, blob, orientation, metadata }) => {\n                const url = URL.createObjectURL(blob); // expensive\n                const cacheKey = await this._cacheKey(blob);\n                this.image = new Image();\n                this.blob = blob;\n                this.meta = metadata || {};\n                this.meta.orientation = orientation || 1;\n                this.type = blob.type;\n                this.image.onload = () => {\n                    if (canvas && canvas instanceof HTMLCanvasElement) {\n                        this._fixIOSCCanvas(canvas);\n                        this.canvas = canvas;\n                    }\n                    else if (feature_lib_1.Capabilities.canSupportCanvas()) {\n                        this.canvas = this._imageToCanvas(this.image, options);\n                    }\n                    this.width = this.image.naturalWidth;\n                    this.height = this.image.naturalHeight;\n                    if (this.useCache && !this._hasCache(cacheKey)) {\n                        this.logger.debug(`Saving ${this.width}x${this.height} image to cache with key: ${cacheKey}`);\n                        this._saveCache(cacheKey);\n                    }\n                    this._trigger(\"load\", { target: this, type: IMAGE_EVENT_TYPES.LOAD });\n                    if (this.image.onload)\n                        this.image.onload = null;\n                    if (this.image.onerror)\n                        this.image.onerror = null;\n                    URL.revokeObjectURL(this.image.src);\n                    resolve(this);\n                };\n                this.image.onerror = (e) => {\n                    this._trigger(\"error\", {\n                        error: e,\n                        target: this,\n                        type: IMAGE_EVENT_TYPES.ERROR,\n                    });\n                    if (this.image.onload)\n                        this.image.onload = null;\n                    if (this.image.onerror)\n                        this.image.onerror = null;\n                    URL.revokeObjectURL(this.image.src);\n                    reject(e);\n                };\n                this.image.src = url;\n            })\n                .catch(reject);\n        });\n    }\n    /**\n     * Restore image data from cache.\n     * @param {ImageInput} input - The image input to restore.\n     * @param {ImageLoadOptions} [options] - Options for loading the image.\n     * @returns {Promise<ExtendedImage>} - A promise that resolves with the restored image.\n     * @scope private\n     */\n    _hydrate(input, options) {\n        const that = this;\n        const opts = typeof options === \"object\" ? options : {};\n        const decodeOnFail = typeof opts.decodeOnFail === \"undefined\" ? true : !!opts.decodeOnFail;\n        return new Promise((resolve, reject) => {\n            this._cacheKey(input).then((cacheKey) => {\n                if (this._hasCache(cacheKey)) {\n                    try {\n                        this.logger.debug(`Cache hit for key: ${cacheKey}. Hydrating image.`);\n                        const cacheEntry = that._getCache(cacheKey);\n                        const { blob, meta } = cacheEntry;\n                        this.blob = blob;\n                        this.meta = meta || {};\n                        this.meta.orientation = this.meta.orientation || 1;\n                        this.type = blob?.type || \"\";\n                        this.image = new Image();\n                        this.image.onload = () => {\n                            if (feature_lib_1.Capabilities.canSupportCanvas()) {\n                                that.canvas = that._imageToCanvas(that.image, opts);\n                            }\n                            that.width = that.image.naturalWidth;\n                            that.height = that.image.naturalHeight;\n                            that._trigger(\"load\", { target: that, type: IMAGE_EVENT_TYPES.LOAD });\n                            if (that.image.onload)\n                                that.image.onload = null;\n                            if (that.image.onerror)\n                                that.image.onerror = null;\n                            URL.revokeObjectURL(that.image.src);\n                            resolve(that);\n                        };\n                        this.image.onerror = (e) => {\n                            that._trigger(\"error\", {\n                                error: e,\n                                target: that,\n                                type: IMAGE_EVENT_TYPES.ERROR,\n                            });\n                            if (that.image.onload)\n                                that.image.onload = null;\n                            if (that.image.onerror)\n                                that.image.onerror = null;\n                            URL.revokeObjectURL(that.image.src);\n                            reject(e);\n                        };\n                        that.image.src = URL.createObjectURL(blob);\n                        return;\n                    }\n                    catch (error) {\n                        that.logger.error(`Error hydrating image from cache: ${error.message}`);\n                    }\n                }\n                // If cache miss or error, decode the image\n                if (decodeOnFail) {\n                    this.logger.debug(`Cache miss for key: ${cacheKey}. Decoding image.`);\n                    this._decode(input, opts)\n                        .then((image) => {\n                        if (image.useCache && !this._hasCache(cacheKey)) {\n                            this.logger.debug(`Saving decoded`, `${image.width}x${image.height}`, `image to cache with key:`, `${cacheKey}`);\n                            image._saveCache(cacheKey);\n                        }\n                        resolve(image);\n                    })\n                        .catch((error) => {\n                        that._trigger(\"error\", {\n                            error: error,\n                            target: that,\n                            type: IMAGE_EVENT_TYPES.ERROR,\n                        });\n                        reject(error);\n                    });\n                }\n                else {\n                    reject(new Error(\"Image not found in cache.\"));\n                }\n            });\n        });\n    }\n    /**\n     * Checks if the current environment is iOS.\n     * @returns {boolean} - True if the environment is iOS, false otherwise.\n     * @scope private\n     */\n    _isIOS() {\n        return feature_lib_2.Env.os === \"iOS\";\n    }\n    /**\n     * Scale the image using multi-pass scaling.\n     * @param {HTMLCanvasElement} srcCanvas - The source canvas to scale.\n     * @param {number} targetW - The target width.\n     * @param {number} targetH - The target height.\n     * @returns {HTMLCanvasElement} - The scaled canvas.\n     * @description This method performs multi-pass scaling to reduce the image size.\n     * It repeatedly scales down the image by half until it reaches the target dimensions.\n     * This approach helps maintain image quality by avoiding large single-step reductions.\n     * @private\n     * @throws {Error} If the source canvas is smaller than the target dimensions.\n     */\n    _multiPassScale(srcCanvas, targetW, targetH) {\n        let canvas = srcCanvas;\n        while (canvas.width * 0.5 > targetW || canvas.height * 0.5 > targetH) {\n            const temp = document.createElement(\"canvas\");\n            temp.width = Math.max(targetW, canvas.width * 0.5);\n            temp.height = Math.max(targetH, canvas.height * 0.5);\n            temp.getContext(\"2d\").drawImage(canvas, 0, 0, temp.width, temp.height);\n            this._fixIOSCCanvas(temp);\n            canvas = temp;\n        }\n        const final = document.createElement(\"canvas\");\n        final.width = targetW;\n        final.height = targetH;\n        final.getContext(\"2d\").drawImage(canvas, 0, 0, final.width, final.height);\n        this._fixIOSCCanvas(final);\n        return final;\n    }\n    /**\n     * Scale the image to the target dimensions.\n     * @param {HTMLCanvasElement} srcCanvas - The source canvas to scale.\n     * @param {number} targetW - The target width.\n     * @param {number} targetH - The target height.\n     * @returns {HTMLCanvasElement} - The scaled canvas.\n     * @description This method creates a new canvas and draws the source canvas onto it\n     * at the target dimensions. It does not perform any quality enhancements.\n     * @private\n     */\n    _scale(srcCanvas, targetW, targetH) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = targetW;\n        canvas.height = targetH;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(srcCanvas, 0, 0, targetW, targetH);\n        this._fixIOSCCanvas(canvas);\n        return canvas;\n    }\n    /**\n     * Calculate the maximum dimensions for an image.\n     * @param {Dimensional} image - The image element to resize.\n     * @param {number} maxWH - The maximum width or height.\n     * @returns {Dimensional} - The max dimensions for the image.\n     * @private\n     */\n    _calcMaxDimensions(image, maxWH) {\n        const { width, height } = image;\n        // No limit or image already within bounds\n        if (!maxWH || maxWH <= 0 || (width <= maxWH && height <= maxWH)) {\n            return { width, height };\n        }\n        // Scale dimensions proportionally\n        if (width >= height) {\n            const scaledHeight = Math.round((height * maxWH) / width);\n            return { width: maxWH, height: scaledHeight };\n        }\n        else {\n            const scaledWidth = Math.round((width * maxWH) / height);\n            return { width: scaledWidth, height: maxWH };\n        }\n    }\n    /**\n     * Get the metadata thumbnail.\n     * @returns {Promise<ExtendedImage | null>} - The thumbnail image or null if not available.\n     * @private\n     */\n    async _getMetaThumbnail() {\n        const tn = this.meta.thumbnail;\n        let thumb;\n        if (tn && tn instanceof Blob) {\n            this.logger.debug(\"Using thumbnail from metadata.\");\n            // Use thumbnail if available\n            thumb = new ExtendedImage();\n            return await thumb.load(tn);\n        }\n        return null;\n    }\n    // --- Canvas Manipulation ---\n    /**\n     * Crops the canvas to the specified dimensions.\n     * @param {HTMLCanvasElement} canvas - The canvas to crop.\n     * @param {ImageResizeOptions} options - The cropping options.\n     * @returns {HTMLCanvasElement} - The cropped canvas.\n     * @private\n     */\n    _cropCanvas(canvas, options) {\n        let sx = 0, sy = 0, ow = canvas.width, oh = canvas.height, sw = canvas.width, sh = canvas.height, width = options.width || 0, height = options.height || 0;\n        const { fit = true, multipass = false } = options, cropped = document.createElement(\"canvas\"), srcRatio = canvas.width / canvas.height, tgtRatio = width / height;\n        if (srcRatio > tgtRatio) {\n            sw = Math.round(canvas.height * tgtRatio);\n            sx = Math.round((canvas.width - sw) / 2);\n        }\n        else {\n            sh = Math.round(canvas.width / tgtRatio);\n            sy = Math.round((canvas.height - sh) / 2);\n        }\n        cropped.width = sw;\n        cropped.height = sh;\n        cropped.getContext(\"2d\").drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);\n        this._fixIOSCCanvas(cropped);\n        // Apply `fit` constraint: don't upscale if source is smaller\n        if (!fit && cropped.width < width && cropped.height < height) {\n            width = ow;\n            height = oh;\n        }\n        this.width = width;\n        this.height = height;\n        if (multipass) {\n            return this._multiPassScale(cropped, width, height);\n        }\n        else {\n            return this._scale(cropped, width, height);\n        }\n    }\n    /**\n     * Clone the canvas.\n     * @param {HTMLCanvasElement} canvas - The canvas to clone.\n     * @returns {HTMLCanvasElement} - The cloned canvas.\n     * @scope private\n     */\n    _cloneCanvas(canvas) {\n        const cloned = document.createElement(\"canvas\");\n        cloned.width = canvas.width;\n        cloned.height = canvas.height;\n        cloned.getContext(\"2d\").drawImage(canvas, 0, 0);\n        try {\n            this._fixIOSCCanvas(cloned);\n        }\n        catch (error) {\n            this.logger.warn(\"Error fixing iOS canvas:\", error);\n        }\n        return cloned;\n    }\n    /**\n     * Release the canvas by resizing it to 1x1 and clearing the context\n     * @param {HTMLCanvasElement} canvas\n     * @scope private\n     */\n    _releaseCanvas(canvas) {\n        if (!canvas || !(canvas instanceof HTMLCanvasElement))\n            return;\n        try {\n            if (!document.body.contains(canvas)) {\n                canvas.width = 1;\n                canvas.height = 1;\n                const ctx = canvas.getContext(\"2d\");\n                ctx && ctx.clearRect(0, 0, 1, 1);\n                if (typeof canvas.remove === \"function\")\n                    canvas.remove();\n            }\n        }\n        catch (error) {\n            this.logger.warn(\"Error releasing canvas:\", error);\n        }\n    }\n    /**\n     * Fix iOS canvas issue\n     * @param {HTMLCanvasElement} canvas - The canvas element to fix.\n     * @scope private\n     */\n    _fixIOSCCanvas(canvas) {\n        if (!this._isIOS())\n            return;\n        const ctx = canvas.getContext(\"2d\");\n        const h = canvas.height, w = canvas.width;\n        if (h < 10)\n            return; // No need to fix if height is less than 10px\n        try {\n            const data = ctx.getImageData(0, Math.max(0, h - 10), w, 10)?.data;\n            if (!data || !data.length)\n                return; // No data to check\n            let transparent = true;\n            for (let i = 3; i < data.length; i += 4) {\n                if (data[i] !== 0) {\n                    transparent = false;\n                    break;\n                }\n            }\n            if (transparent)\n                canvas.height -= Math.min(10, canvas.height);\n        }\n        catch (error) {\n            this.logger.debug(\"Error fixing iOS canvas:\", error);\n        }\n    }\n    // --- Conversion ---\n    /**\n     * Convert a Canvas element to a Blob.\n     * @param {HTMLCanvasElement} canvas - The canvas to convert.\n     * @param {number} [quality=0.9] - The quality of the image (0 to 1).\n     * @param {boolean} [preserveHeaders=false] - Whether to preserve EXIF headers.\n     * @returns {Promise<Blob>} - A promise that resolves with the resulting Blob.\n     * @scope private\n     */\n    _canvasToBlob(canvas, quality, preserveHeaders) {\n        const qualityValue = typeof quality !== \"undefined\" ? quality : this.quality;\n        const normalizedQuality = qualityValue > 1 ? qualityValue / 100 : qualityValue <= 0 ? 0.9 : qualityValue;\n        return new Promise((resolve, reject) => {\n            try {\n                canvas.toBlob((blob) => {\n                    if (blob) {\n                        if (preserveHeaders && this.meta && this.meta.rawEXIF) {\n                            // Inject the preserved EXIF data into the new Blob\n                            imageReader_lib_1.ImageReader.injectBlobExif(blob, this.meta.rawEXIF)\n                                .then((exifBlob) => {\n                                resolve(exifBlob);\n                            })\n                                .catch(() => {\n                                this.logger.warn(\"Failed to inject EXIF data, falling back to original Blob.\");\n                                resolve(blob);\n                            });\n                        }\n                        else {\n                            resolve(blob);\n                        }\n                    }\n                    else {\n                        reject(new Error(\"Failed to convert canvas to Blob\"));\n                    }\n                }, this.type || \"image/jpeg\", normalizedQuality);\n            }\n            catch (e) {\n                reject(new Error(`Canvas to Blob conversion failed: ${e.message}`));\n            }\n        });\n    }\n    /**\n     * Convert a Blob to an Image element.\n     * @param {Blob} blob - The Blob to convert.\n     * @returns {Promise<HTMLImageElement>} - A promise that resolves with the Image element.\n     * @static\n     * @description This function creates a temporary URL for the Blob, loads it into an Image element,\n     * and resolves the promise with the Image once it has loaded. It also revokes the URL\n     * to free up memory.\n     */\n    _blobToImage(blob) {\n        return new Promise((resolve, reject) => {\n            const url = URL.createObjectURL(blob); // expensive\n            const img = new Image();\n            img.onload = () => {\n                //URL.revokeObjectURL(url);\n                resolve(img);\n            };\n            img.onerror = reject;\n            img.src = url;\n        });\n    }\n    /**\n     * Convert an Image element to a Canvas element.\n     * @param {HTMLImageElement} image - The Image element to convert.\n     * @param {ImageLoadOptions} [options] - Options for loading the image.\n     * @returns {HTMLCanvasElement} - The resulting Canvas element.\n     * @scope private\n     */\n    _imageToCanvas(image, options) {\n        const { maxWidthOrHeight = 0 } = options || {}, r = Math.round, resized = this._calcMaxDimensions(image, maxWidthOrHeight), canvas = document.createElement(\"canvas\");\n        canvas.width = r(resized.width);\n        canvas.height = r(resized.height);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, r(resized.width), r(resized.height));\n        this._fixIOSCCanvas(canvas);\n        return canvas;\n    }\n    // --- Caching ---\n    /**\n     * Retrieves image data from the cache.\n     * @param {string} cacheKey - The key to identify the cached image.\n     * @returns {ImageCacheEntry} - The cached image object containing blob and metadata, or null if not found.\n     * @throws {Error} If the cache entry is not found.\n     * @private\n     */\n    _getCache(cacheKey) {\n        const cached = ExtendedImage._cache.get(cacheKey);\n        if (cached)\n            return { blob: cached.blob, meta: cached.meta };\n        throw new Error(`Cache entry not found for key: ${cacheKey}`);\n    }\n    /**\n     * Checks if the cache contains an image with the given key.\n     * @param {string} cacheKey - The key to check in the cache.\n     * @returns {boolean} - True if the cache contains the image, false otherwise.\n     * @private\n     */\n    _hasCache(cacheKey) {\n        return ExtendedImage._cache.has(cacheKey);\n    }\n    /**\n     * Saves the current image data to the cache.\n     * @param {string} cacheKey - The key to identify the cached image.\n     * @private\n     */\n    _saveCache(cacheKey) {\n        const blob = this.blob ? (0, functions_1.deep_clone)(this.blob) : null, meta = typeof this.meta === \"object\" ? (0, functions_1.deep_clone)(this.meta) : null;\n        ExtendedImage._cache.set(cacheKey, { blob, meta });\n    }\n    /**\n     * Generates a content-based cache key.\n     * @param {ImageInput} input\n     * @returns {Promise<string>} - The generated cache key.\n     * @private\n     */\n    async _cacheKey(input) {\n        const source = typeof input.getSource === \"function\" ? input.getSource() : input;\n        if (typeof source === \"string\") {\n            const metadata = `${this.fit ? \"fit\" : \"\"}-` +\n                `${this.crop ? \"crop\" : \"\"}-` +\n                `${this.preserveHeaders ? \"preserveHeaders\" : \"\"}`;\n            return `${source}-${metadata}`;\n        }\n        if (source instanceof File || source instanceof Blob) {\n            const chunkSize = 512; // Read first 512 bytes for hashing\n            const slice = source.slice(0, chunkSize);\n            const buffer = await slice.arrayBuffer();\n            const hashBuffer = await crypto.subtle.digest(\"SHA-1\", buffer);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n            return `blob-${hashHex}`;\n        }\n        return `unknown-${this._uuid()}`; // fallback for unexpected input types\n    }\n    /**\n     * Generates a UUID.\n     * @returns {string} - A UUID string.\n     * @private\n     */\n    _uuid() {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n            const r = (Math.random() * 16) | 0;\n            const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }\n    // --- Events ---\n    /**\n     * Registers an event listener.\n     * @param {string} evt - The event name.\n     * @param {ImageEventHandler} fn - The event handler.\n     */\n    on(evt, fn) {\n        if (!this._events)\n            return;\n        if (typeof evt !== \"string\" || typeof fn !== \"function\") {\n            this.logger.warn(`Event name: ${evt} must be a string and handler must be a function.`);\n            return;\n        }\n        this._events[evt] = this._events[evt] || [];\n        this._events[evt].push(fn.bind(this));\n    }\n    /**\n     * Unregisters an event listener.\n     * @param {string} evt - The event name.\n     * @param {ImageEventHandler} fn - The event handler.\n     */\n    off(evt, fn) {\n        if (typeof evt !== \"string\")\n            return;\n        if (!this._events?.[evt])\n            return;\n        if (fn) {\n            this._events[evt] = this._events[evt].filter((f) => f !== fn);\n        }\n        else {\n            delete this._events[evt];\n        }\n    }\n    /**\n     * Binds multiple events to a single handler.\n     * @param {string|Array<string>} evts - The event name(s) to bind.\n     * @param {ImageEventHandler} fn - The event handler.\n     */\n    bind(evts, fn) {\n        let _evts;\n        if (typeof evts === \"string\") {\n            _evts = evts\n                .split(\" \")\n                .map((e) => e.trim().toLowerCase())\n                .filter((e) => !!e);\n        }\n        else if (Array.isArray(evts)) {\n            _evts = evts\n                .filter((e) => typeof e === \"string\")\n                .map((e) => e.trim().toLowerCase())\n                .filter((e) => !!e);\n        }\n        else {\n            _evts = [];\n        }\n        _evts.forEach((evt) => this.on(evt, fn));\n    }\n    /**\n     * Triggers an event.\n     * @param {string} eventName - The event name.\n     * @param {ImageEvent} event - The triggered event.\n     * @private\n     */\n    _trigger(eventName, event) {\n        const list = this._events[eventName];\n        if (list)\n            list.forEach((fn) => fn(event));\n    }\n}\nexports.ExtendedImage = ExtendedImage;\nExtendedImage._cache = new Map();\nExtendedImage.EVENT_TYPES = IMAGE_EVENT_TYPES;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Env = exports.Capabilities = void 0;\nconst uaparser_lib_1 = require(\"./features/uaparser.lib\");\n/**\n * Feature detection capabilities\n * @type {Record<string, FeatureCapabilityFn>}\n * @description This object contains methods to check browser capabilities such as auto-rotating images\n * based on EXIF orientation, support for Blob objects, and support for Data URIs\n * with a size of 32KB or more.\n * @property {FeatureCapabilityFn} canAutoRotateImages - Checks if the browser can auto-rotate images based on EXIF orientation\n * @property {FeatureCapabilityFn} canSupportBlobs - Checks if the browser supports Blob objects\n * @property {FeatureCapabilityFn} canSupport32KbDataURI - Checks if the browser supports Data URIs with 32KB size\n */\nexports.Capabilities = {\n    /**\n     * Checks if the browser can automatically rotate images based on EXIF orientation\n     * @returns {boolean} - True if the browser can auto-rotate images, false otherwise\n     */\n    canAutoRotateImages: (function () {\n        let result = null;\n        return function () {\n            if (result !== null) {\n                return result;\n            }\n            // 1. Modern feature-query\n            if (window.CSS && CSS.supports) {\n                try {\n                    if (CSS.supports(\"image-orientation\", \"from-image\")) {\n                        result = true;\n                        return result;\n                    }\n                }\n                catch (_) {\n                    // CSS.supports exists but threwignore and fall through\n                }\n            }\n            // 2. Vendor-prefixed CSS property check\n            const img = document.createElement(\"img\");\n            const s = img.style;\n            if (\"imageOrientation\" in s ||\n                \"webkitImageOrientation\" in s ||\n                \"mozImageOrientation\" in s ||\n                \"msImageOrientation\" in s) {\n                result = true;\n                return result;\n            }\n            // 3. Computed-style fallback (like your original test)\n            try {\n                img.style.display = \"none\";\n                document.body.appendChild(img);\n                // Try to detect whether the browser honors EXIF orientation automatically\n                result = window.getComputedStyle && window.getComputedStyle(img).imageOrientation === \"from-image\";\n                document.body.removeChild(img);\n            }\n            catch (_) {\n                result = false;\n                document.body.removeChild(img);\n            }\n            return result;\n        };\n    })(),\n    /**\n     * Checks if the browser supports Blob objects\n     * @returns {boolean} - True if Blob is supported, false otherwise\n     */\n    canSupportBlobs: function () {\n        try {\n            return !!new Blob();\n        }\n        catch (_) {\n            return false;\n        }\n    },\n    /**\n     * Checks if the browser supports Data URIs with 32KB size\n     * @returns {boolean} - True if >= 32KB Data URIs are supported, false otherwise\n     */\n    canSupport32KbDataURI: function () {\n        return \"IE\" !== exports.Env.browser || !exports.Env.version || parseFloat(exports.Env.version) >= 9;\n    },\n    /**\n     * Checks if the browser supports canvas elements\n     * @returns {boolean} - True if canvas is supported, false otherwise\n     */\n    canSupportCanvas: function () {\n        return !!document.createElement(\"canvas\").getContext || !!window.OffscreenCanvas;\n    },\n};\nconst uaResult = new uaparser_lib_1.UAParser().getResult();\n/**\n * Global environment variables for the uploader.\n * Contains information about the user agent, browser, version, concurrency,OS, and OS version.\n */\nexports.Env = {\n    uaParser: uaparser_lib_1.UAParser,\n    agent: uaResult.ua,\n    browser: uaResult.browser.name,\n    version: uaResult.browser.version,\n    os: uaResult.os.name,\n    osVersion: uaResult.os.version,\n    hardwareConcurrency: navigator?.hardwareConcurrency || 2,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Logger = exports.LOG_LEVEL = void 0;\nconst window_1 = require(\"./types/window\");\n/**\n * LOG_LEVEL\n * @enum {number}\n * This enum represents the different logging levels used in the application.\n * @property {number} DEBUG - Debug level logging\n * @property {number} INFO - Informational level logging\n * @property {number} WARN - Warning level logging\n * @property {number} ERROR - Error level logging\n */\nvar LOG_LEVEL;\n(function (LOG_LEVEL) {\n    LOG_LEVEL[LOG_LEVEL[\"DEBUG\"] = 0] = \"DEBUG\";\n    LOG_LEVEL[LOG_LEVEL[\"INFO\"] = 1] = \"INFO\";\n    LOG_LEVEL[LOG_LEVEL[\"WARN\"] = 2] = \"WARN\";\n    LOG_LEVEL[LOG_LEVEL[\"ERROR\"] = 3] = \"ERROR\";\n})(LOG_LEVEL || (exports.LOG_LEVEL = LOG_LEVEL = {}));\n/**\n * Logger class\n * A simple logger that supports different log levels.\n * @class Logger\n */\nclass Logger {\n    constructor(logLevel = LOG_LEVEL.INFO) {\n        this.logLevel = LOG_LEVEL.INFO;\n        this.logLevel = logLevel;\n        this.initialize();\n    }\n    /**\n     * Initialize the logger by binding console methods to the appropriate log level.\n     * @scope private\n     * @returns {void}\n     */\n    initialize() {\n        const fns = Object.values(LOG_LEVEL)\n            .filter((v) => typeof v === \"string\")\n            .map((v) => v.toLowerCase());\n        for (const fn of fns) {\n            const level = LOG_LEVEL[fn.toUpperCase()];\n            if (typeof this[fn] === \"function\") {\n                switch (level) {\n                    case LOG_LEVEL.ERROR:\n                    case LOG_LEVEL.WARN:\n                        this[fn] = this.logLevel <= level ? console[fn].bind(console) : () => { };\n                        break;\n                    case LOG_LEVEL.INFO:\n                    case LOG_LEVEL.DEBUG:\n                        this[fn] = this.logLevel <= level ? console.log.bind(console) : () => { };\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n    /**\n     * Get singleton instance of Logger\n     * @param {LOG_LEVEL} [logLevel] - Optional log level to set. If not provided, it will use the log level from pageData or default to LogLevel.INFO.\n     * @returns {Logger} - The singleton instance of Logger.\n     * @static\n     */\n    static getInstance(logLevel) {\n        if (!Logger.instance) {\n            // fallback to pageData.loglevel if no level passed\n            const actual = typeof logLevel !== \"undefined\"\n                ? logLevel\n                : typeof window_1.pageData !== \"undefined\" && typeof window_1.pageData.loglevel !== \"undefined\"\n                    ? window_1.pageData.loglevel\n                    : LOG_LEVEL.INFO;\n            Logger.instance = new Logger(actual);\n        }\n        return Logger.instance;\n    }\n    /**\n     * Set the logging level\n     * @param {LOG_LEVEL | string} logLevel - The log level to set. Can be a LogLevel enum value or a string representation of the level.\n     */\n    static setLogLevel(logLevel) {\n        let _level = LOG_LEVEL.INFO;\n        if (typeof logLevel === \"string\") {\n            if (/^[0-3]$/.test(logLevel)) {\n                _level = parseInt(logLevel, 10);\n            }\n            else if (Object.keys(LOG_LEVEL).includes(logLevel.toUpperCase())) {\n                _level = LOG_LEVEL[logLevel.toUpperCase()];\n            }\n        }\n        else if (typeof logLevel === \"number\" && Object.values(LOG_LEVEL).includes(logLevel)) {\n            _level = logLevel;\n        }\n        if (Logger.instance) {\n            Logger.instance.logLevel = _level;\n            Logger.instance.initialize();\n        }\n        else {\n            Logger.instance = new Logger(_level);\n        }\n    }\n    /**\n     * Get the current logging level\n     * @return {LOG_LEVEL} - The current log level.\n     */\n    static getLogLevel() {\n        return Logger.instance ? Logger.instance.logLevel : LOG_LEVEL.INFO;\n    }\n    /**\n     * Log an error message\n     * @type {LogFn}\n     */\n    error(..._args) { }\n    /**\n     * Log a warning message\n     * @type {LogFn}\n     */\n    warn(..._args) { }\n    /**\n     * Log an info message\n     * @type {LogFn}\n     */\n    info(..._args) { }\n    /**\n     * Log a debug message\n     * @type {LogFn}\n     */\n    debug(..._args) { }\n    /**\n     * Reset the singleton instance\n     */\n    static reset() {\n        Logger.instance = null;\n    }\n}\nexports.Logger = Logger;\nLogger.instance = null;\n// Export default instance for convenience\nexports.default = Logger;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileProcessor = void 0;\n/// <reference types=\"jquery\" />\nconst common_1 = require(\"../types/common\");\nconst console_logger_1 = require(\"../console.logger\");\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\nconst mimeReader_lib_1 = require(\"./mimeReader.lib\");\n/**\n * File Processor class\n * @class FileProcessor\n * @property {ImageUploaderSettings} settings - The configuration settings for the uploader\n * @property {Logger} logger - Logger instance for logging messages\n */\nclass FileProcessor {\n    /**\n     * Constructor for the FileProcessor class\n     * @param {ImageUploaderSettings} settings - The configuration settings for the uploader\n     * @scope public\n     * @constructor\n     */\n    constructor(settings) {\n        this.settings = settings;\n        this.logger = console_logger_1.Logger.getInstance();\n        this._fileSignatures = new Set();\n    }\n    /**\n     * Initialize the uploader with a list of files\n     * @param {File[] | FileList} files - The list of files to initialize the uploader with.\n     * @return {ExtendedFile[]} - An array of ExtendedFile objects initialized with the provided files.\n     */\n    initialize(files) {\n        // Create ExtendedFile objects from the files array or FileList\n        return Array.from(files).map((file) => {\n            return new extendedFile_lib_1.ExtendedFile(file);\n        });\n    }\n    /**\n     * Apply filters to the selected files\n     * @param {File[] | FileList} files\n     * @returns {Promise<ImageFilterResult>} - A promise that resolves with the results of the filter application\n     * @scope public\n     */\n    applyFilters(files) {\n        const results = Promise.allSettled(Array.from(files).map(this._applyFilter.bind(this)));\n        return results.then((results) => {\n            const accepted = [];\n            const rejected = [];\n            for (let i = 0; i < results.length; i++) {\n                const outcome = results[i];\n                const result = outcome.status === \"fulfilled\"\n                    ? outcome.value\n                    : { file: files[i], accepted: false, reason: \"unknown filter rejection\" };\n                (result.accepted ? accepted : rejected).push({\n                    file: result.file,\n                    reason: result.reason,\n                });\n            }\n            return { accepted, rejected };\n        });\n    }\n    /**\n     * Observe and apply filters to the file input\n     * @scope public\n     */\n    observeFilters() {\n        const { filters } = this.settings;\n        // Apply filters to the file input\n        if ($.isPlainObject(filters)) {\n            if (filters?.mime_types) {\n                const acceptedExts = this._mimeToExts(this._getMimeTypes(filters.mime_types));\n                if (acceptedExts.length) {\n                    $(document).trigger(\"mimeType.uploader\", [\".\" + acceptedExts.join(\",.\")]);\n                }\n            }\n            else {\n                this.logger.debug(\"No mime_types filter provided.\");\n            }\n        }\n        else {\n            this.logger.debug(\"Filters are not a plain object, skipping mime type observation.\");\n        }\n    }\n    /**\n     * Get the supported MIME types from the settings\n     * @return {Set<string>} - A set of supported MIME types\n     * @scope public\n     */\n    getSupportedMimes() {\n        const { filters } = this.settings;\n        return this._getMimeTypes(filters?.mime_types);\n    }\n    /**\n     * Apply filters to a single file\n     * @param {File} file - The file to apply filters to\n     * @returns {Promise<FileFilterOutcome>} - The result of the filter application\n     * @scope private\n     */\n    async _applyFilter(file) {\n        const { filters } = this.settings;\n        if (filters && filters.prevent_duplicates && !this._isValidSignature(file)) {\n            return { file, accepted: false, reason: \"prevent_duplicates filter rejected\" };\n        }\n        if (!this._isValidSize(file)) {\n            return { file, accepted: false, reason: \"max_file_size filter rejected\" };\n        }\n        if (!(await this._isValidMime(file))) {\n            return { file, accepted: false, reason: \"mime_types filter rejected\" };\n        }\n        return { file, accepted: true, reason: undefined };\n    }\n    /**\n     * Check the file size of a file\n     * @param {File} file - The file to check\n     * @returns {boolean} - True if the file's size is allowed, false otherwise\n     * @scope private\n     */\n    _isValidSize(file) {\n        const { filters } = this.settings;\n        const maxSize = filters && filters.max_file_size ? this._parseFileSize(filters.max_file_size) : Infinity;\n        if (file.size > maxSize) {\n            return false; // File size exceeds the maximum allowed size\n        }\n        return true;\n    }\n    /**\n     * Check the MIME type of a file\n     * @param {File} file - The file to check\n     * @returns {Promise<boolean>} - True if the file's MIME type is allowed, false otherwise\n     * @scope private\n     */\n    async _isValidMime(file) {\n        const { filters } = this.settings, mimeTypes = filters && filters.mime_types ? this._getMimeTypes(filters.mime_types) : null;\n        if (mimeTypes) {\n            const fileMime = await this._getFileMime(file);\n            if (!mimeTypes.has(fileMime)) {\n                return false; // MIME type does not match\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if a file is a duplicate based on its name and size\n     * @param {File} file - The file to check for duplicates\n     * @return {boolean} - True if the file name and size are unique, false otherwise\n     * @private\n     */\n    _isValidSignature(file) {\n        const hash = `${file.name}-${file.size}`;\n        if (this._fileSignatures.has(hash))\n            return false;\n        this._fileSignatures.add(hash);\n        return true;\n    }\n    /**\n     * Get the MIME type of a file based on its name, type, or content\n     * @param {File} file - The file to get the MIME type for\n     * @return {Promise<string>} - The detected MIME type of the file\n     * @private\n     */\n    _getFileMime(file) {\n        return mimeReader_lib_1.MimeReader.detectMime(file)\n            .then((detectedMime) => {\n            this.logger.debug(`Detected MIME type: ${detectedMime} for file: ${file.name}`);\n            return detectedMime;\n        })\n            .catch((error) => {\n            this.logger.error(`Error detecting MIME type for file: ${file.name}`, error);\n            if (file.type)\n                return file.type;\n            const ext = ((file.name || \"\").split(\".\").pop() || \"\").toLowerCase();\n            return common_1.MIME_TYPES[ext] || \"application/octet-stream\";\n        });\n    }\n    /**\n     * Get MIME types from the given mime-type filter(s)\n     * @param {string | { title: string; extensions: string; }[]} mimeGroups\n     * @returns {Set<string>}\n     * @private\n     */\n    _getMimeTypes(mimeGroups) {\n        if (!Array.isArray(mimeGroups)) {\n            return new Set(this._parseExtensions(mimeGroups || \"\"));\n        }\n        const mimeTypes = mimeGroups.flatMap((group) => {\n            if (!(group && group.title) || !(group && group.extensions)) {\n                this.logger.debug(\"Invalid mime group:\", group);\n                return [];\n            }\n            return this._parseExtensions(group.extensions);\n        });\n        return new Set(mimeTypes);\n    }\n    /**\n     * Parse the extensions string and return an array of MIME types\n     * @param {string} sExtensions\n     * @returns {string[]}\n     * @private\n     */\n    _parseExtensions(sExtensions) {\n        const extList = sExtensions.split(\",\").map((ext) => ext.replace(/^\\./, \"\"));\n        const mimeTypes = new Set();\n        const mimeValueSet = new Set(Object.values(common_1.MIME_TYPES));\n        for (let i = 0; i < extList.length; i++) {\n            const extension = extList[i].trim().toLowerCase();\n            if (extension === \"image/*\") {\n                mimeValueSet.forEach((mime) => {\n                    if (mime.startsWith(\"image/\")) {\n                        mimeTypes.add(mime);\n                    }\n                });\n            }\n            else if (common_1.MIME_TYPES[extension]) {\n                mimeTypes.add(common_1.MIME_TYPES[extension]);\n            }\n            else {\n                if (mimeValueSet.has(extension)) {\n                    mimeTypes.add(extension);\n                }\n            }\n        }\n        return Array.from(mimeTypes);\n    }\n    /**\n     * Parse the file size string and return the size in bytes\n     * @param {number | string} size\n     * @returns {number}\n     * @private\n     */\n    _parseFileSize(size) {\n        if (typeof size === \"number\") {\n            return size;\n        }\n        if (typeof size !== \"string\") {\n            throw new Error(\"Invalid input: file size must be a number or a string.\");\n        }\n        const units = {\n            b: 1,\n            kb: 1024,\n            mb: 1024 ** 2,\n            gb: 1024 ** 3,\n            tb: 1024 ** 4,\n            pb: 1024 ** 5,\n        };\n        const regex = /^([\\d.]+)\\s*(b|kb|mb|gb|tb|pb)?([A-Za-z]*)?$/i;\n        const match = size.trim().match(regex);\n        if (!match) {\n            throw new Error(\"Invalid file size format.\");\n        }\n        const value = parseFloat(match[1]);\n        const unit = match[2] ? match[2].toLowerCase() : match[3] ? match[3].toLowerCase() : \"b\";\n        if (!units[unit]) {\n            throw new Error(`Unknown unit: ${unit}`);\n        }\n        return value * units[unit];\n    }\n    /**\n     * Convert MIME types to extensions\n     * @param {string[] | Set<string>} _mimeTypes\n     * @returns {string[]}\n     * @private\n     */\n    _mimeToExts(_mimeTypes) {\n        const mimeTypes = Array.from(_mimeTypes);\n        const exts = new Set();\n        for (let i = 0; i < mimeTypes.length; i++) {\n            for (let ext in common_1.MIME_TYPES) {\n                if (common_1.MIME_TYPES[ext] === mimeTypes[i]) {\n                    exts.add(ext);\n                }\n            }\n        }\n        return Array.from(exts);\n    }\n}\nexports.FileProcessor = FileProcessor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueManager = void 0;\n/**\n * QueueManager class for managing a queue of file upload tasks with concurrency control\n * @class QueueManager\n * @scope public\n */\nclass QueueManager {\n    /**\n     * Creates a new QueueManager instance\n     * @param {number} concurrency - The maximum number of concurrent tasks allowed\n     * @constructor\n     */\n    constructor(concurrency) {\n        this.queue = [];\n        this.active = new Set();\n        this.concurrency = concurrency && concurrency > 0 ? concurrency : 1;\n    }\n    /**\n     * Enqueue a task to be executed with concurrency control\n     * @param {Function} taskFn - The function to execute as a task\n     * @returns {Promise} - A promise that resolves when the task is complete\n     * @scope public\n     */\n    enqueue(taskFn) {\n        return new Promise((resolve, reject) => {\n            const task = {\n                run: async () => {\n                    try {\n                        this.active.add(task.run);\n                        const result = await taskFn();\n                        resolve(result);\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                    finally {\n                        this.active.delete(task.run);\n                        this._dequeue();\n                    }\n                },\n                reject: (reason) => {\n                    reject(reason ?? new Error(\"Queued task canceled before execution\"));\n                },\n            };\n            this.queue.push(task);\n            this._dequeue();\n        });\n    }\n    /**\n     * Dequeue tasks and execute them if concurrency allows\n     * @private\n     */\n    _dequeue() {\n        while (this.active.size < this.concurrency && this.queue.length > 0) {\n            const task = this.queue.shift();\n            if (task) {\n                task.run();\n            }\n        }\n    }\n    /**\n     * Get the current size of the queue\n     * @returns {number} - The total number of tasks in the queue\n     * @scope public\n     */\n    size() {\n        return this.queue.length + this.active.size;\n    }\n    /**\n     * Get the current load (number of active/pending tasks)\n     * @param {boolean} [pending] - Whether to count pending tasks (default: false)\n     * @returns {number} - The number of active tasks\n     * @scope public\n     */\n    load(pending) {\n        return pending ? this.queue.length : this.active.size;\n    }\n    /**\n     * Check if the queue is idle (no active tasks and no queued tasks)\n     * @returns {boolean} - Returns true if the queue is idle, false otherwise\n     * @scope public\n     */\n    isIdle() {\n        return this.queue.length === 0 && this.active.size === 0;\n    }\n    /**\n     * Returns a promise that resolves when the entire queue is drained and all active tasks are done\n     * @returns {Promise<void>}\n     */\n    wait() {\n        return new Promise((resolve) => {\n            const checkIdle = () => {\n                if (this.isIdle()) {\n                    resolve();\n                }\n                else {\n                    setTimeout(checkIdle, 100);\n                }\n            };\n            checkIdle();\n        });\n    }\n    /**\n     * Clear the queue and reset active tasks\n     * @scope public\n     */\n    clear(reason) {\n        for (const task of this.queue) {\n            task.reject(reason ? (typeof reason === \"string\" ? new Error(reason) : reason) : reason);\n        }\n        this.queue = [];\n        this.active.clear();\n    }\n    /**\n     * Gets the current concurrency level\n     * @returns {number} - The current concurrency level\n     * @scope public\n     */\n    getConcurrency() {\n        return this.concurrency;\n    }\n    /**\n     * Sets the current concurrency level\n     * @param {number} concurrency - The new concurrency level\n     * @scope public\n     */\n    setConcurrency(concurrency) {\n        this.concurrency = concurrency;\n    }\n    /**\n     * Returns the singleton instance of QueueManager\n     * @param {number} [concurrency] - The maximum number of concurrent tasks allowed\n     * @returns {QueueManager}\n     * @scope public\n     * @static\n     */\n    static getInstance(concurrency) {\n        if (!QueueManager.instance) {\n            QueueManager.instance = new QueueManager(concurrency);\n        }\n        return QueueManager.instance;\n    }\n}\nexports.QueueManager = QueueManager;\nQueueManager.instance = null;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PluginRegistry = void 0;\nconst console_logger_1 = require(\"../console.logger\");\nconst window_1 = require(\"../types/window\");\nconst feature_lib_1 = require(\"../libs/feature.lib\");\nconst extendedFile_lib_1 = require(\"../libs/extendedFile.lib\");\nconst imageReader_lib_1 = require(\"../libs/imageReader.lib\");\nconst mimeReader_lib_1 = require(\"../libs/mimeReader.lib\");\nconst functions_1 = require(\"../utils/functions\");\n/**\n * Dependency map for various image formats.\n */\nconst DEPENDENCIES = {\n    \"image/*\": [`${window_1.pageData.SURLV}js/uploader/plugins/vips/vips.min.js`],\n    \"image/avif\": [`${window_1.pageData.SURLV}js/uploader/plugins/avif/jsquash.bundle.js`],\n    \"image/heic\": [`${window_1.pageData.SURLV}js/uploader/plugins/heic/heic2any.min.js`],\n    \"image/heif\": [`${window_1.pageData.SURLV}js/uploader/plugins/heic/heic2any.min.js`],\n    \"image/bmp\": [\n        `${window_1.pageData.SURLV}js/uploader/plugins/bmp/bmp-js.min.js`,\n        `${window_1.pageData.SURLV}js/uploader/plugins/avif/jsquash.bundle.js`,\n    ],\n};\n/**\n * PluginRegistry class\n * Manages the registration and loading of image processing plugins.\n * @class\n */\nclass PluginRegistry {\n    /**\n     * Checks if the current environment is iOS.\n     * @returns {boolean} - True if the environment is iOS, false otherwise.\n     * @scope private\n     */\n    static _isIOS() {\n        return feature_lib_1.Env.os === \"iOS\";\n    }\n    /**\n     * Dynamically loads one or more scripts, ensuring each is only loaded once.\n     * @param {string | string[]} urls - One or more script URLs to load\n     * @param {Partial<Record<keyof HTMLScriptElement, string>>} $attrs - Attributes to set on the script element\n     * @returns {Promise<void>} Promise that resolves when all scripts are loaded\n     * @scope private\n     */\n    static _loadScripts(urls, $attrs = {}) {\n        // For arrays, always return a new promise (Promise.all)\n        if (Array.isArray(urls)) {\n            return Promise.all(urls.map((url) => this._loadScripts(url, $attrs))).then(() => undefined);\n        }\n        const url = urls;\n        if (PluginRegistry._loadedScripts.has(url))\n            return PluginRegistry._loadedScripts.get(url);\n        const promise = new Promise((resolve, reject) => {\n            const script = document.createElement(\"script\");\n            script.src = url;\n            script.async = true;\n            script.onload = () => resolve();\n            script.onerror = () => reject(new Error(`Failed to load script: ${url}`));\n            Object.entries($attrs).forEach(([key, value]) => {\n                script.setAttribute(key, value);\n            });\n            document.head.appendChild(script);\n        });\n        PluginRegistry._loadedScripts.set(url, promise);\n        return promise;\n    }\n    /**\n     * Normalizes input to a Blob, File, or ExtendedFile.\n     * @param {string | File | Blob | ExtendedFile} input - The input to normalize\n     * @returns {Promise<File | Blob>} - Resolves with a File or Blob\n     * @scope private\n     */\n    static _normalizeInput(input) {\n        return new Promise((resolve, reject) => {\n            if (typeof input === \"string\") {\n                fetch(input)\n                    .then((response) => response.blob())\n                    .then((blob) => resolve(blob))\n                    .catch(reject);\n            }\n            else if (input instanceof extendedFile_lib_1.ExtendedFile) {\n                resolve(input.getSource());\n            }\n            else if (input instanceof File || input instanceof Blob) {\n                resolve(input);\n            }\n            else {\n                reject(new Error(\"Unsupported input type\"));\n            }\n        });\n    }\n    /**\n     * Draws image data or an image element onto a canvas, applying orientation and resizing.\n     * @param {ImageData | HTMLImageElement} input - Image data or image element\n     * @param {number} orientation - EXIF orientation\n     * @param {number} maxWidthOrHeight - Maximum width or height\n     * @returns {Promise<CanvasType>} Promise that resolves with a canvas\n     * @scope private\n     */\n    static __imageToCanvas(input, orientation, maxWidthOrHeight) {\n        return new Promise((resolve, reject) => {\n            if (!PluginRegistry._CANVAS_SUPPORT) {\n                return reject(new Error(\"Canvas and OffscreenCanvas are not supported in this environment\"));\n            }\n            const { width, height } = imageReader_lib_1.ImageReader.calcMaxDimensions(input, maxWidthOrHeight);\n            const renderToCanvas = (source) => {\n                const canvas = window.OffscreenCanvas\n                    ? new OffscreenCanvas(width, height)\n                    : document.createElement(\"canvas\");\n                canvas.width = width;\n                canvas.height = height;\n                const ctx = PluginRegistry._AUTO_ROTATE\n                    ? canvas.getContext(\"2d\")\n                    : imageReader_lib_1.ImageReader.exifTransformCanvas(canvas, orientation);\n                if (source instanceof HTMLImageElement) {\n                    ctx.drawImage(source, 0, 0, source.width, source.height, 0, 0, width, height);\n                    resolve(canvas);\n                }\n                else if (source instanceof ImageData) {\n                    ctx.putImageData(source, 0, 0);\n                    resolve(canvas);\n                }\n                else if (source instanceof ImageBitmap) {\n                    ctx.drawImage(source, 0, 0, source.width, source.height, 0, 0, width, height);\n                    resolve(canvas);\n                }\n                else {\n                    reject(new Error(\"Unsupported input type for rendering to canvas\"));\n                }\n            };\n            try {\n                if (input instanceof HTMLImageElement) {\n                    renderToCanvas(input);\n                }\n                else {\n                    createImageBitmap(input, {\n                        resizeWidth: width,\n                        resizeHeight: height,\n                        resizeQuality: \"high\",\n                    })\n                        .then(renderToCanvas)\n                        .catch(reject);\n                }\n            }\n            catch (error) {\n                reject(new Error(`Failed to convert source image: ${error.message}`));\n            }\n        });\n    }\n    /**\n     * Converts a canvas to a JPEG blob.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - Canvas element\n     * @param {number} quality - JPEG quality between 0 and 1\n     * @returns {Promise<Blob>} Promise that resolves with a Blob\n     * @scope private\n     */\n    static __canvasToBlob(canvas, quality) {\n        return new Promise((resolve, reject) => {\n            if (canvas instanceof OffscreenCanvas) {\n                canvas\n                    .convertToBlob({\n                    type: \"image/jpeg\",\n                    quality: quality,\n                })\n                    .then(resolve)\n                    .catch(reject);\n            }\n            else if (canvas instanceof HTMLCanvasElement) {\n                canvas.toBlob((blob) => {\n                    if (blob) {\n                        resolve(blob);\n                    }\n                    else {\n                        reject(new Error(\"Failed to convert canvas to blob\"));\n                    }\n                }, \"image/jpeg\", quality);\n            }\n            else {\n                reject(new Error(\"Unsupported canvas type for conversion to Blob\"));\n            }\n        });\n    }\n    static __canRunVips() {\n        const agent = feature_lib_1.Env.agent;\n        // Chrome iOS on iPad\n        if (/\\bCriOS\\b/.test(agent) && /iPad/.test(agent)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Initializes the Vips library.\n     * @returns {Promise<any>} Resolves with the Vips module\n     * @static\n     */\n    static initVips() {\n        return new Promise((resolve, reject) => {\n            if (PluginRegistry.__canRunVips()) {\n                if (!PluginRegistry._vips) {\n                    const $attrs = { crossOrigin: \"anonymous\" };\n                    PluginRegistry._loadScripts(DEPENDENCIES[\"image/*\"], $attrs).then(async () => {\n                        const vipsOptions = {\n                            locateFile: (fileName, scriptDirectory) => `${scriptDirectory}${fileName}`,\n                            print: (stdout) => PluginRegistry._logger.debug(stdout.replace(/\\\\x1b\\[[0-9;]*m/g, \"\")),\n                            noImageDecoding: true,\n                            dynamicLibraries: [],\n                            preRun: (module) => {\n                                module.setAutoDeleteLater(true);\n                                module.setDelayFunction((fn) => {\n                                    window.cleanup = fn;\n                                });\n                            },\n                            postRun: (module) => {\n                                const pad = 30;\n                                const have = (name) => module.Utils.typeFind(\"VipsOperation\", name) !== 0;\n                                PluginRegistry._logger.debug(\"vips version:\".padEnd(pad), module.version());\n                                PluginRegistry._logger.debug(\"Emscripten version:\".padEnd(pad), module.emscriptenVersion());\n                                PluginRegistry._logger.debug(\"Concurrency:\".padEnd(pad), module.concurrency());\n                                PluginRegistry._logger.debug(\"Cache max mem:\".padEnd(pad), module.Cache.maxMem());\n                                PluginRegistry._logger.debug(\"Cache max operations:\".padEnd(pad), module.Cache.max());\n                                PluginRegistry._logger.debug(\"Cache current operations:\".padEnd(pad), module.Cache.size());\n                                PluginRegistry._logger.debug(\"Cache max open files:\".padEnd(pad), module.Cache.maxFiles());\n                                PluginRegistry._logger.debug(\"Memory allocations:\".padEnd(pad), module.Stats.allocations());\n                                PluginRegistry._logger.debug(\"Memory currently allocated:\".padEnd(pad), module.Stats.mem());\n                                PluginRegistry._logger.debug(\"Memory high water:\".padEnd(pad), module.Stats.memHighwater());\n                                PluginRegistry._logger.debug(\"Open files:\".padEnd(pad), module.Stats.files());\n                                PluginRegistry._logger.debug(\"JPEG support:\".padEnd(pad), have(\"jpegload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"JPEG XL support:\".padEnd(pad), have(\"jxlload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"AVIF support:\".padEnd(pad), have(\"heifload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"PNG support:\".padEnd(pad), have(\"pngload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"TIFF support:\".padEnd(pad), have(\"tiffload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"WebP support:\".padEnd(pad), have(\"webpload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"GIF support:\".padEnd(pad), have(\"gifload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"SVG load:\".padEnd(pad), have(\"svgload\") ? \"yes\" : \"no\");\n                                PluginRegistry._logger.debug(\"Text rendering support:\".padEnd(pad), have(\"text\") ? \"yes\" : \"no\");\n                            },\n                            printErr: (text) => PluginRegistry._logger.error(\"stderr\", text),\n                        };\n                        if (\"Vips\" in window) {\n                            const _vips = await window.Vips(vipsOptions).catch((error) => {\n                                PluginRegistry._logger.error(\"Failed to initialize Vips:\", error);\n                                return null;\n                            });\n                            if (_vips) {\n                                PluginRegistry._vips = _vips;\n                                resolve(_vips);\n                            }\n                            else {\n                                reject(new Error(`Vips initialization failed`));\n                            }\n                        }\n                        else {\n                            reject(new Error(\"Vips library not loaded\"));\n                        }\n                    });\n                }\n                else {\n                    resolve(PluginRegistry._vips);\n                }\n            }\n            else {\n                reject(new Error(\"Your browser does not support Vips. Vips initialization failed.\"));\n            }\n        });\n    }\n    /**\n     * Preloads necessary plugins based on the image MIME type.\n     * @returns {Promise<void[]>} Resolves when all plugins are loaded\n     * @static\n     */\n    static preloadPlugins() {\n        const promises = [];\n        for (const mimeType in DEPENDENCIES) {\n            if (Object.prototype.hasOwnProperty.call(DEPENDENCIES, mimeType)) {\n                try {\n                    const $attrs = { crossOrigin: \"anonymous\" };\n                    const p = PluginRegistry._loadScripts(DEPENDENCIES[mimeType], $attrs).catch((error) => {\n                        PluginRegistry._logger.error(`Error loading plugin for ${mimeType}:`, error);\n                    });\n                    promises.push(p);\n                }\n                catch (error) {\n                    PluginRegistry._logger.error(`Error preparing plugin for ${mimeType}:`, error);\n                    promises.push(Promise.resolve());\n                }\n            }\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * Decodes an AVIF image file.\n     * @type {ImageDecoderPluginFn}\n     * @param {ImageInput} input - The file to decode\n     * @param {ImageLoadOptions} [options] - Options for decoding\n     * @returns {Promise<ImageDecodeResult>} - Resolves with the decoded image data, canvas, and metadata\n     * @static\n     */\n    static _decodeAvif(input, options) {\n        const { quality = 1, maxWidthOrHeight = 4096 } = options || {};\n        return new Promise((resolve, reject) => {\n            PluginRegistry._normalizeInput(input)\n                .then((file) => {\n                mimeReader_lib_1.MimeReader.detectMime(file)\n                    .then((mimeType) => {\n                    if (mimeType !== \"image/avif\") {\n                        return reject(new Error(\"File is not an AVIF image\"));\n                    }\n                    const $attrs = { crossOrigin: \"anonymous\" };\n                    PluginRegistry._loadScripts(DEPENDENCIES[\"image/avif\"], $attrs)\n                        .then(async () => {\n                        if (\"jSquash\" in window && window.jSquash.avif) {\n                            try {\n                                const metadata = await imageReader_lib_1.ImageReader.getEXIF(file);\n                                const buffer = await file.arrayBuffer();\n                                const decoded = await window.jSquash.avif.decode(buffer);\n                                const imageData = decoded instanceof ImageData\n                                    ? decoded\n                                    : new ImageData(new Uint8ClampedArray(decoded.data), decoded.width, decoded.height);\n                                const jpegBuffer = await window.jSquash.jpeg.encode(imageData, { quality: quality * 100 });\n                                const blob = new Blob([jpegBuffer], { type: \"image/jpeg\" });\n                                const result = {\n                                    blob: blob,\n                                    orientation: metadata.orientation || 1,\n                                    metadata: metadata,\n                                };\n                                if (!PluginRegistry._CANVAS_SUPPORT)\n                                    return resolve(result);\n                                PluginRegistry.__imageToCanvas(imageData, metadata.orientation || 1, maxWidthOrHeight)\n                                    .then((canvas) => {\n                                    result.canvas = canvas;\n                                    return PluginRegistry.__canvasToBlob(canvas, quality);\n                                })\n                                    .then((blob) => {\n                                    result.blob = blob;\n                                    resolve(result);\n                                })\n                                    .catch(() => {\n                                    resolve(result);\n                                });\n                            }\n                            catch (error) {\n                                reject(new Error(`AVIF decode failed: ${error.message}`));\n                            }\n                        }\n                        else {\n                            reject(new Error(\"jSquash AVIF plugin not loaded\"));\n                        }\n                    })\n                        .catch((error) => {\n                        reject(new Error(`Failed to load AVIF plugin: ${error.message}`));\n                    });\n                })\n                    .catch((error) => {\n                    reject(new Error(`Unknown file type: ${error.message}`));\n                });\n            })\n                .catch((error) => {\n                reject(new Error(`Unknown input for decoding AVIF: ${error.message}`));\n            });\n        });\n    }\n    /**\n     * Decodes a HEIC or HEIF image file.\n     * @type {ImageDecoderPluginFn}\n     * @param {ImageInput} input - The file to decode\n     * @param {ImageLoadOptions} [options] - Options for decoding\n     * @returns {Promise<ImageDecodeResult>} - Resolves with the decoded image data, canvas, and metadata\n     * @static\n     */\n    static _decodeHeic(input, options) {\n        const { quality = 1, maxWidthOrHeight = 4096 } = options || {};\n        return new Promise((resolve, reject) => {\n            PluginRegistry._normalizeInput(input)\n                .then((file) => {\n                mimeReader_lib_1.MimeReader.detectMime(file)\n                    .then((mimeType) => {\n                    if (mimeType !== \"image/heic\" && mimeType !== \"image/heif\") {\n                        return reject(new Error(\"File is not a HEIC image\"));\n                    }\n                    const $attrs = { crossOrigin: \"anonymous\" };\n                    PluginRegistry._loadScripts(DEPENDENCIES[\"image/heic\"], $attrs)\n                        .then(async () => {\n                        if (\"heic2any\" in window && window.heic2any) {\n                            try {\n                                const metadata = await imageReader_lib_1.ImageReader.getEXIF(file);\n                                const blob = (await window.heic2any({\n                                    blob: file,\n                                    toType: \"image/jpeg\",\n                                    quality: quality,\n                                }));\n                                const result = {\n                                    blob: blob,\n                                    orientation: metadata.orientation || 1,\n                                    metadata: metadata,\n                                };\n                                if (!PluginRegistry._CANVAS_SUPPORT)\n                                    return resolve(result);\n                                const url = URL.createObjectURL(blob);\n                                const img = new Image();\n                                img.onload = () => {\n                                    PluginRegistry.__imageToCanvas(img, metadata.orientation || 1, maxWidthOrHeight)\n                                        .then((canvas) => {\n                                        result.canvas = canvas;\n                                        return PluginRegistry.__canvasToBlob(canvas, quality);\n                                    })\n                                        .then((blob) => {\n                                        result.blob = blob;\n                                        resolve(result);\n                                    })\n                                        .catch(() => {\n                                        resolve(result);\n                                    })\n                                        .finally(() => {\n                                        URL.revokeObjectURL(url);\n                                    });\n                                };\n                                img.onerror = () => {\n                                    URL.revokeObjectURL(url);\n                                    resolve(result);\n                                };\n                                img.src = url;\n                            }\n                            catch (error) {\n                                reject(new Error(`HEIC decode failed: ${error.message}`));\n                            }\n                        }\n                        else {\n                            reject(new Error(\"HEIC plugin not loaded\"));\n                        }\n                    })\n                        .catch((error) => {\n                        reject(new Error(`Failed to load HEIC plugin: ${error.message}`));\n                    });\n                })\n                    .catch((error) => {\n                    reject(new Error(`Unknown file type: ${error.message}`));\n                });\n            })\n                .catch((error) => {\n                reject(new Error(`Unknown input for decoding HEIC: ${error.message}`));\n            });\n        });\n    }\n    /**\n     * Decodes a BMP image file.\n     * @type {ImageDecoderPluginFn}\n     * @param {ImageInput} input - The file to decode\n     * @param {ImageLoadOptions} [options] - Options for decoding\n     * @returns {Promise<ImageDecodeResult>} - Resolves with the decoded image data, canvas, and metadata\n     * @static\n     */\n    static _decodeBmp(input, options) {\n        const { quality = 1, maxWidthOrHeight = 4096 } = options || {};\n        return new Promise((resolve, reject) => {\n            PluginRegistry._normalizeInput(input)\n                .then((file) => {\n                mimeReader_lib_1.MimeReader.detectMime(file)\n                    .then((mimeType) => {\n                    if (mimeType !== \"image/bmp\") {\n                        return reject(new Error(\"File is not a BMP image\"));\n                    }\n                    const $attrs = { crossOrigin: \"anonymous\" };\n                    PluginRegistry._loadScripts(DEPENDENCIES[\"image/bmp\"], $attrs)\n                        .then(async () => {\n                        if (\"bmpJs\" in window && \"jSquash\" in window) {\n                            try {\n                                const metadata = await imageReader_lib_1.ImageReader.getEXIF(file);\n                                const arrayBuffer = await file.arrayBuffer();\n                                const nodeBuffer = window.bmpJs.Buffer.from(arrayBuffer);\n                                const decoded = await window.bmpJs.decode(nodeBuffer);\n                                const imageData = new ImageData(new Uint8ClampedArray(decoded.data.buffer), decoded.width, decoded.height);\n                                const jpegBuffer = await window.jSquash.jpeg.encode(imageData, {\n                                    quality: quality * 100,\n                                });\n                                const blob = new Blob([jpegBuffer], { type: \"image/jpeg\" });\n                                const result = {\n                                    blob: blob,\n                                    orientation: metadata.orientation || 1,\n                                    metadata: metadata,\n                                };\n                                if (!PluginRegistry._CANVAS_SUPPORT)\n                                    return resolve(result);\n                                PluginRegistry.__imageToCanvas(imageData, metadata.orientation || 1, maxWidthOrHeight)\n                                    .then((canvas) => {\n                                    result.canvas = canvas;\n                                    return PluginRegistry.__canvasToBlob(canvas, quality);\n                                })\n                                    .then((blob) => {\n                                    result.blob = blob;\n                                    resolve(result);\n                                })\n                                    .catch(() => {\n                                    resolve(result);\n                                });\n                            }\n                            catch (error) {\n                                reject(new Error(`BMP decode failed: ${error.message}`));\n                            }\n                        }\n                        else {\n                            reject(new Error(\"BMP plugin not loaded\"));\n                        }\n                    })\n                        .catch((error) => {\n                        reject(new Error(`Failed to load BMP plugin: ${error.message}`));\n                    });\n                })\n                    .catch((error) => {\n                    reject(new Error(`Unknown file type: ${error.message}`));\n                });\n            })\n                .catch((error) => {\n                reject(new Error(`Unknown input for decoding BMP: ${error.message}`));\n            });\n        });\n    }\n    /**\n     * Decodes JPEG, PNG, GIF, WEBP, and TIFF images using the Vips library.\n     * @type {ImageDecoderPluginFn}\n     * @param {ImageInput} input - The file to decode\n     * @param {ImageLoadOptions} [options] - Options for decoding\n     * @returns {Promise<ImageDecodeResult>} - Resolves with the decoded image data, canvas, and metadata\n     * @static\n     */\n    static _decodeVips(input, options) {\n        const { quality = 1, maxWidthOrHeight = 4096 } = options || {}, supportedMimeTypes = [\"image/jpeg\", \"image/gif\", \"image/png\", \"image/webp\", \"image/tiff\"];\n        return new Promise((resolve, reject) => {\n            PluginRegistry._normalizeInput(input)\n                .then((file) => {\n                mimeReader_lib_1.MimeReader.detectMime(file)\n                    .then((mimeType) => {\n                    if (supportedMimeTypes.indexOf(mimeType) === -1) {\n                        return reject(new Error(\"File is not a supported image type\"));\n                    }\n                    try {\n                        PluginRegistry.initVips()\n                            .then(async () => {\n                            if (PluginRegistry._vips) {\n                                const Vips = PluginRegistry._vips;\n                                let arrayBuffer = await file.arrayBuffer();\n                                let imageBuffer = new Uint8Array(arrayBuffer);\n                                try {\n                                    const metadata = await imageReader_lib_1.ImageReader.getEXIF(file), image = Vips.Image.newFromBuffer(imageBuffer), scale = maxWidthOrHeight / Math.max(image.width, image.height), resized = scale < 1 ? image.resize(scale) : image;\n                                    // Convert to JPEG buffer\n                                    PluginRegistry._logger.debug(`Orientation: ${metadata.orientation}`, `Auto-rotation: ${PluginRegistry._AUTO_ROTATE}`);\n                                    const outputBytes = resized.writeToBuffer(\".jpg\");\n                                    const blob = new Blob([outputBytes], { type: \"image/jpeg\" });\n                                    const result = {\n                                        blob: blob,\n                                        orientation: metadata.orientation || 1,\n                                        metadata: metadata,\n                                    };\n                                    if (!PluginRegistry._CANVAS_SUPPORT)\n                                        return resolve(result);\n                                    const url = URL.createObjectURL(blob);\n                                    const img = new Image();\n                                    img.onload = () => {\n                                        PluginRegistry.__imageToCanvas(img, metadata.orientation || 1, maxWidthOrHeight)\n                                            .then((canvas) => {\n                                            result.canvas = canvas;\n                                            return PluginRegistry.__canvasToBlob(canvas, quality);\n                                        })\n                                            .then((blob) => {\n                                            result.blob = blob;\n                                            resolve(result);\n                                        })\n                                            .catch(() => {\n                                            resolve(result);\n                                        })\n                                            .finally(() => {\n                                            imageBuffer = new Uint8Array(0);\n                                            arrayBuffer = new ArrayBuffer(0);\n                                            URL.revokeObjectURL(url);\n                                        });\n                                    };\n                                    img.onerror = () => {\n                                        arrayBuffer = new ArrayBuffer(0);\n                                        imageBuffer = new Uint8Array(0);\n                                        URL.revokeObjectURL(url);\n                                        resolve(result);\n                                    };\n                                    img.src = url;\n                                }\n                                catch (err) {\n                                    PluginRegistry._logger.error(\"Error converting image:\", err);\n                                    reject(new Error(`Error converting image: ${err.message}`));\n                                }\n                            }\n                            else {\n                                reject(new Error(\"VIPs plugin not loaded\"));\n                            }\n                        })\n                            .catch((error) => {\n                            reject(new Error(`Failed to load VIPs plugin: ${error.message}`));\n                        });\n                    }\n                    catch (error) {\n                        reject(new Error(`Failed to initialize VIPS: ${error.message}`));\n                    }\n                })\n                    .catch((error) => {\n                    reject(new Error(`Unknown file type: ${error.message}`));\n                });\n            })\n                .catch((error) => {\n                reject(new Error(`Unknown input for decoding image: ${error.message}`));\n            });\n        });\n    }\n    /**\n     * Returns the registry of image decoder plugins.\n     * @returns {ImageDecoderRegistry} The registry of image decoder plugins\n     * @static\n     */\n    static getPlugins() {\n        const k = Object.keys, _equal = (a, b) => k(a).length === k(b).length && k(a).every((key) => a[key] === b[key]);\n        if (!this._registry || !_equal(this._registry, PluginRegistry.registry)) {\n            this._registry = (0, functions_1.deep_clone)(PluginRegistry.registry);\n        }\n        return this._registry;\n    }\n}\nexports.PluginRegistry = PluginRegistry;\n/**\n * Logger instance for logging messages.\n * @static\n * @scope private\n */\nPluginRegistry._logger = console_logger_1.Logger.getInstance();\n/**\n * A map to keep track of loaded scripts, ensuring each script is only loaded once.\n * This prevents multiple requests for the same script, which can lead to performance issues.\n * @scope private\n */\nPluginRegistry._loadedScripts = new Map();\n/**\n * AUTO_ROTATE\n * Indicates whether the uploader can automatically rotate images based on EXIF data.\n */\nPluginRegistry._AUTO_ROTATE = feature_lib_1.Capabilities.canAutoRotateImages();\n/**\n * CANVAS_SUPPORT\n * Indicates whether the uploader can use canvas elements for image processing.\n */\nPluginRegistry._CANVAS_SUPPORT = feature_lib_1.Capabilities.canSupportCanvas();\n/**\n * A registry of plugins for handling specific image formats.\n * This registry maps MIME types to their corresponding decoding functions.\n * It allows the uploader to dynamically load and use plugins for image formats like AVIF and HEIC/HEIF.\n * @type {Record<string, ImageDecoderPluginFn>}\n * @private\n */\nPluginRegistry.registry = {\n    \"image/avif\": PluginRegistry._decodeAvif,\n    \"image/heic\": PluginRegistry._decodeHeic,\n    \"image/heif\": PluginRegistry._decodeHeic,\n    \"image/bmp\": PluginRegistry._decodeBmp,\n    \"image/tiff\": PluginRegistry._decodeVips,\n    \"image/*\": PluginRegistry._decodeVips,\n};\nPluginRegistry.preloadPlugins()\n    .catch((error) => console_logger_1.Logger.getInstance().error(\"Failed to preload conversion plugin(s):\", error))\n    .then(PluginRegistry.initVips)\n    .catch((error) => console_logger_1.Logger.getInstance().error(\"Failed to initialize VIPS library:\", error));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventManager = void 0;\nconst console_logger_1 = require(\"../console.logger\");\nconst functions_1 = require(\"../utils/functions\");\nconst extendedFile_lib_1 = require(\"./extendedFile.lib\");\n/**\n * EventManager class for managing event listeners\n * @class EventManager\n * @property {Object.<string, function[]>} handlers - Object to hold event handlers\n * @property {Logger} logger - Logger instance for logging messages\n * @property {Object} counts - Object to hold upload statistics\n * @property {number} counts.total - Total number of files to upload\n * @property {number} counts.uploaded - Number of files successfully uploaded\n * @property {number} counts.failed - Number of files that failed to upload\n * @property {Object.<string, number>} counts.progress - Object to hold progress percentages\n * @property {ImageUploaderSettings} settings - Configuration settings for the uploader\n */\nclass EventManager {\n    /**\n     * Creates an instance of EventManager.\n     * @param {ImageUploaderSettings} settings - Configuration settings for the uploader\n     * @constructor\n     */\n    constructor(settings) {\n        this.handlers = {};\n        this.settings = settings;\n        this.logger = console_logger_1.Logger.getInstance();\n        this.counts = { total: 0, uploaded: 0, failed: 0, progress: {} };\n    }\n    /**\n     * Register an event handler\n     * @param {string} event - The event name\n     * @param {function} handler - The function to call when the event is emitted\n     * @scope public\n     */\n    on(event, handler) {\n        if (!this.handlers[event]) {\n            this.handlers[event] = [];\n        }\n        this.handlers[event].push(handler);\n    }\n    /**\n     * Unregister an event handler\n     * @param {string} event - The event name\n     * @param {function} handler - The function to remove from the event's handlers\n     * @scope public\n     */\n    off(event, handler) {\n        if (this.handlers[event]) {\n            const handlers = this.handlers[event];\n            const index = handlers.indexOf(handler);\n            if (index !== -1) {\n                handlers.splice(index, 1); // Remove only the first occurrence\n            }\n        }\n    }\n    /**\n     * Emit an event, calling all registered handlers with the provided arguments\n     * @param {string} event - The event name\n     * @param {...*} args - Arguments to pass to the event handlers\n     * @scope public\n     */\n    emit(event, ...args) {\n        // 1. Internal callbacks\n        if (this.handlers[event]) {\n            this.handlers[event].forEach((handler) => handler(...args));\n        }\n        // 2. jQuery .trigger()\n        if (this.settings.targetElement) {\n            try {\n                this.settings.targetElement.trigger(event, args);\n            }\n            catch (error) {\n                this.logger.error(`Error triggering jQuery event \"${event}\":`, error);\n            }\n        }\n    }\n    /**\n     * Calls the initialize callback function\n     * @returns {any}\n     * @scope public\n     */\n    onInitialize() {\n        const result = typeof this.settings.initialize === \"function\" ? this.settings.initialize() : undefined;\n        this.emit(\"initialize.uploader\", [result]);\n        return result;\n    }\n    /**\n     * Calls the onBeforeQueue callback function\n     * @param {ExtendedFile[]} files\n     * @returns {ExtendedFile[] | boolean | void}\n     * @scope public\n     */\n    onBeforeQueue(files) {\n        const result = typeof this.settings.onBeforeQueue === \"function\" ? this.settings.onBeforeQueue(files) : files;\n        this.emit(\"onBeforeQueue.uploader\", [files, result]);\n        if (Array.isArray(result)) {\n            this.counts.total = result.length;\n            this.counts.progress = result.reduce((acc, file) => {\n                acc[file.id] = 0;\n                return acc;\n            }, {});\n        }\n        else if (result !== false) {\n            this.counts.total = files.length;\n            this.counts.progress = files.reduce((acc, file) => {\n                acc[file.id] = 0;\n                return acc;\n            }, {});\n        }\n        return result;\n    }\n    /**\n     * Calls the onS3FilePresign callback function\n     * @param {ExtendedFile} file - The file being uploaded.\n     * @param {any} media - The media information for the file.\n     * @param {S3PutTicket} ticket - The S3 PUT ticket for the file.\n     * @returns {void}\n     * @scope public\n     */\n    onS3FilePresign(file, media, ticket) {\n        if (typeof this.settings.onS3FilePresign === \"function\") {\n            this.settings.onS3FilePresign(file, media, ticket);\n        }\n        this.emit(\"onS3FilePresign.uploader\", [file, media, ticket]);\n    }\n    /**\n     * Calls the onBeforeChunkUpload callback function\n     * @param {ExtendedFile} file - The file being uploaded.\n     * @param {ChunkUploadArgs} args - Additional arguments for the upload.\n     * @param {Blob} chunkBlob - The blob representing the current chunk of the file.\n     * @param {number} offset - The offset of the chunk in the file.\n     * @returns {any}\n     * @scope public\n     */\n    onBeforeChunkUpload(file, args, chunkBlob, offset) {\n        const result = typeof this.settings.onBeforeChunkUpload === \"function\"\n            ? this.settings.onBeforeChunkUpload(file, args, chunkBlob, offset)\n            : undefined;\n        this.emit(\"onBeforeChunkUpload.uploader\", [file, args, chunkBlob, offset, result]);\n        return result;\n    }\n    /**\n     * Calls the onBeforeUpload callback function\n     * @param {ExtendedFile} file - The file being uploaded.\n     * @returns {ExtendedFile | boolean | void}\n     * @scope public\n     */\n    onBeforeUpload(file) {\n        const result = typeof this.settings.onBeforeUpload === \"function\" ? this.settings.onBeforeUpload(file) : file;\n        this.emit(\"onBeforeUpload.uploader\", [file, result]);\n        return result;\n    }\n    /**\n     * Calls the onPreviewThumbnail callback function\n     * @param {ExtendedFile} file - The file for which the thumbnail is being previewed.\n     * @param {jQuery<HTMLCanvasElement> | JQuery} $canvas - The jQuery canvas element where the thumbnail will be displayed.\n     * @returns {any}\n     * @scope public\n     */\n    onPreviewThumbnail(file, canvas) {\n        const result = typeof this.settings.onPreviewThumbnail === \"function\"\n            ? this.settings.onPreviewThumbnail(file, canvas)\n            : undefined;\n        this.emit(\"onPreviewThumbnail.uploader\", [file, canvas, result]);\n        return result;\n    }\n    /**\n     * Calls the onUploadProgress callback function\n     * @param {ExtendedFile} file\n     * @param {number} progress\n     * @returns {void}\n     * @scope public\n     */\n    onUploadProgress(file, progress) {\n        this.counts.progress[file.id] = Math.max(0, Math.min(progress, 100));\n        const { uploaded, failed, total } = this.counts, completed = uploaded + failed, queued = Math.max(0, total - completed), stats = { uploaded, failed, queued, percent: this._calcTotalProgress() };\n        if (typeof this.settings.onUploadProgress === \"function\") {\n            this.settings.onUploadProgress(file, progress, stats);\n        }\n        this.emit(\"onUploadProgress.uploader\", [file, progress, stats]);\n    }\n    /**\n     * Calls the onChunkUploadComplete callback function\n     * @param {ExtendedFile} file\n     * @param {any} response\n     * @returns {void}\n     * @scope public\n     */\n    onChunkUploadComplete(file, response) {\n        if (typeof this.settings.onChunkUploadComplete === \"function\") {\n            this.settings.onChunkUploadComplete(file, response);\n        }\n        this.emit(\"onChunkUploadComplete.uploader\", [file, response]);\n    }\n    /**\n     * Calls the onFileUploadComplete callback function\n     * @param {ExtendedFile} file\n     * @param {any} response\n     * @returns {void}\n     * @scope public\n     */\n    onFileUploadComplete(file, response) {\n        this.counts.uploaded++;\n        this.counts.progress[file.id] = 100;\n        if (typeof this.settings.onFileUploadComplete === \"function\") {\n            this.settings.onFileUploadComplete(file, response);\n        }\n        this.emit(\"onFileUploadComplete.uploader\", [file, response]);\n    }\n    /**\n     * Calls the onAllUploadsComplete callback function\n     * @param {ExtendedFile[]} files\n     * @returns {void}\n     * @scope public\n     */\n    onAllUploadsComplete(files) {\n        if (typeof this.settings.onAllUploadsComplete === \"function\") {\n            this.settings.onAllUploadsComplete(files);\n        }\n        this.emit(\"onAllUploadsComplete.uploader\", [files]);\n    }\n    /**\n     * Calls the onFileError callback function\n     * @param {ExtendedFile | File} file\n     * @param {any} error\n     * @returns {void}\n     * @scope public\n     */\n    onFileError(file, error) {\n        this.counts.failed++;\n        if (file instanceof extendedFile_lib_1.ExtendedFile)\n            this.counts.progress[file.id] = 100;\n        if (typeof this.settings.onFileError === \"function\") {\n            this.settings.onFileError(file, error);\n        }\n        this.emit(\"onFileError.uploader\", [file, error]);\n    }\n    /**\n     * Calls the onError callback function\n     * @param {any} error\n     * @returns {void}\n     * @scope public\n     */\n    onError(error) {\n        if (typeof this.settings.onError === \"function\") {\n            this.settings.onError(error);\n        }\n        this.emit(\"onError.uploader\", [error]);\n    }\n    /**\n     * Reset the uploader to its initial state\n     * @scope public\n     */\n    reset() {\n        this.counts = { total: 0, uploaded: 0, failed: 0, progress: {} };\n        this.logger.debug(\"EventManager reset.\");\n    }\n    /**\n     * Returns the total progress percentage\n     * @returns {number}\n     * @private\n     */\n    _calcTotalProgress() {\n        const { progress: oProgress } = this.counts, ids = Object.keys(oProgress), completed = ids.reduce((acc, key) => {\n            return oProgress[key] / 100 + acc;\n        }, 0);\n        return (completed / ids.length) * 100;\n    }\n    /**\n     * Returns the singleton instance of EventManager\n     * @param {ImageUploaderSettings} settings - Configuration settings for the uploader\n     * @returns {EventManager}\n     * @throws {Error} If settings are invalid or not provided\n     * @scope public\n     * @static\n     */\n    static getInstance(settings) {\n        if (!EventManager.instance) {\n            if (!settings || !(0, functions_1.is_plain_object)(settings)) {\n                throw new Error(\"A valid settings object is required for new EventManager instances.\");\n            }\n            EventManager.instance = new EventManager(settings);\n        }\n        return EventManager.instance;\n    }\n}\nexports.EventManager = EventManager;\n// Singleton holder\nEventManager.instance = null;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(88);\n"],"names":["Object","defineProperty","exports","value","VERSION","NAME","OBJ_TYPE","UNDEF_TYPE","FUNC_TYPE","UNKNOWN","EMPTY","UploadRequestFactory","imagePostRequest_lib_1","require","imageS3Request_lib_1","constructor","settings","this","create","ticket","request","transportMode","ImagePostRequest","Error","ImageS3Request","ImageReader","console_logger_1","functions_1","mimeReader_lib_1","extendedFile_lib_1","feature_lib_1","registerPlugin","mimeType","decoderFn","_plugins","push","decode","input","options","blob","_normalizeInput","mime","MimeReader","detectMime","_logger","debug","_decodePlugin","_isNativeSupported","_maybeDecodeNative","getEXIF","that","Promise","resolve","reject","reader","FileReader","onload","e","rawEXIF","thumbnail","orientation","buffer","target","result","view","DataView","getUint16","exifData","__getRawEXIFData","tiffOffset","littleEndian","_rawEXIF","IFD0Offset","IFD1Offset","__getEXIFOrientation","__getEXIFThumbnail","error","warn","onerror","slice","arrayBuffer","then","buf","offset","byteLength","readAsArrayBuffer","fullEXIFSize","injectBlobExif","exifView","byteOffset","__parseExifMetadata","entryCount","ptr","i","setUint16","segLen","segment","Uint8Array","set","resizedAB","orig","out","length","subarray","Blob","type","calcMaxDimensions","imageData","maxWH","width","height","exifTransformCanvas","canvas","originalWidth","originalHeight","ctx","HTMLCanvasElement","getContext","translate","scale","rotate","Math","PI","includes","_isIOS","Env","os","response","fetch","File","ExtendedFile","getSource","_sniffNativeResolution","file","header","getUint32","getUint8","__getDataViewUint24","__sniffJPEGResolution","SOF_MARKERS","stream","getReader","bytesRead","done","read","newBuffer","marker","cancel","_imageDecodeBlob","maxWidthOrHeight","maxSize","preserveHeaders","canvasSupport","Capabilities","canSupportCanvas","metadata","catch","fixOrientation","is_numeric","canAutoRotateImages","img","_blobToImage","document","createElement","drawImage","_canvasToBlob","_bitmapDecodeBlob","window","createImageBitmap","bitmap","imageOrientation","url","URL","createObjectURL","Image","revokeObjectURL","src","quality","toBlob","message","decoder","DECODERS","decoderOrder","__shouldUseNativeDecoder","BITMAP","IMAGE","PLUGIN","stage","inMemoryDecoder","find","p","MIN_DENSITY","MIN_IOS_AREA","mp","bytesPerMP","size","sectionLength","app1Start","app1Total","nextIFDPtr","validPtr","numEntries","tagOffset","numTags","thumbOffset","thumbLength","tag","valueOffset","_","every","b","bom","nextPtrOff","Logger","getInstance","__importDefault","mod","__esModule","ImageUploader","defaults_data_1","uploadController_lib_1","$targetElement","is_uri","uploadUrl","resize","merge_options","RESIZE_DEFAULTS","thumbnails","THUMB_SIZE_DEFAULTS","s3Options","S3_OPTIONS_DEFAULTS","writable","enumerable","configurable","assign","defaultOptions","uploader","UploadController","logger","default","initialize","initializeFileInput","dropElement","initializeDropZone","getOption","option","setOption","reset","destroy","$browseButton","$","browseButton","off","$fileInput","remove","undefined","$dropZone","removeData","val","removeClass","_validateInput","id","multiple","tagName","on","_e","acceptedExts","attr","is","preventDefault","stopPropagation","trigger","css","display","append","Date","now","files","filesAdded","dragDropEnabled","addClass","originalEvent","dataTransfer","props","prop","prototype","hasOwnProperty","call","imageUploader","imageUploader_lib_1","methodOrOptions","args","instance","data","method","apply","each","el","$el","fn","oses","engines","browsers","maps_data_1","mapper_lib_1","common_data_1","mapper","str","maps","browser","oldsafari","version","windows","ImageTransformer","extendedImage_lib_1","resizeToBlob","params","ExtendedImage","name","getAsBlob","downsize","crop","resizedBlob","resizedFile","lastModified","bind","load","is_plain_object","t","n","toString","getPrototypeOf","Function","is_array","Array","isArray","deep_merge","source","get_type","clone_value","tType","sType","res","maxLen","max","key","Reflect","ownKeys","getTime","re","RegExp","flags","m","Map","forEach","v","k","s","Set","add","map","keys","sym","getOwnPropertySymbols","r","echo","console","log","join","_getFuncName","exec","_isNormalInteger","string","number","floor","Number","Infinity","String","_makeIndent","idtLevel","__getType","inp","match","types","cons","toLowerCase","_repeatChar","len","padChar","_getInnerVal","thickPad","ret","parseFloat","parseInt","funcLines","split","fll","nodeName","nodeType","namespaceURI","test","nodeValue","_formatArray","obj","curDepth","padVal","visitedObjects","basePad","lgth","has","var_dump","someProp","objVal","var_export","mixedExpression","boolReturn","recursionDepth","initialIdtLevel","_var_export_impl","isInitialCall","retstr","iret","cnt","x","funcParts","idtLevelValue","innerIndent","outerIndent","subtype","replace","output","mixedVar","whitespace","indexOf","isNaN","isFinite","prop_exists","base","override","required","address","trim","absoluteUrlPattern","relativeUrlPattern","deep_clone","structuredClone","ArrayBuffer","isView","ctor","copiedBuffer","entries","values","debounce","wait","leading","trailing","lastArgs","lastThis","leadingInvoked","invoke","debounced","clearTimeout","setTimeout","flush","throttle","timeout","lastCallTime","deferPromise","promise","rej","path","filter","Boolean","current","UploadPipeline","common_1","eventManager_lib_1","imageTransformer_lib_1","queueManager_lib_1","requestFactory_lib_1","thumbnailService_lib_1","active","thumbnailService","ThumbnailService","imageTransformer","eventManager","EventManager","requestFactory","ticketQueue","QueueManager","transformQueue","PIPELINE_CONCURRENCY","transform","requestQueue","promises","batchSize","_normalizeBatchSize","batch","isActive","clear","setConcurrency","process","JSON","stringify","getConcurrency","onProgressThrottled","_onQueueProgress","_hasBatchS3Tickets","_batchQueueTickets","_queueTicket","_queueTransform","tasks","all","_queueRequest","err","status","FILE_STATUS","QUEUED","CANCELED","allSettled","_isS3TransportMode","enqueue","_getTicket","get","_processThumbnail","_processTransform","_sendRequest","deferreds","deferred","_getTickets","tickets","d","isS3Transfer","hasS3BatchTickets","transLoad","reqLoad","tickBatchLoad","tickLoad","tickActive","maxDefaultTicketConcurrency","maxTicketConcurrency","round","maxConcurrency","maxTransformConcurrency","maxRequestConcurrency","parallel","reqConcurrency","transConcurrency","tickConcurrency","upstreamPressure","isMobile","_isMobileDevice","min","generate","onBeforeUpload","FAILED","onFileError","_makeRequest","UPLOADING","onUploadProgress","send","onFileUploadComplete","setFile","presignOpts","fileData","xhr","XMLHttpRequest","open","setRequestHeader","payload","statusText","responseText","parse","errors","filename","results","onS3FilePresign","media","reduce","acc","f","fileId","S3_TICKET_BATCH_SIZE","agent","imageRequest_lib_1","ImageRequest","super","chunkSize","loaded","percent","_uploadNextChunk","chunkBlob","curChunkSize","target_name","sendChunkNumber","chunk","ceil","chunks","total","onBeforeChunkUpload","_uploadChunk","upload","onprogress","_onFileProgress","_handleError","retries","maxRetries","onChunkUploadComplete","responseHeaders","getAllResponseHeaders","_delay","origSize","DONE","completeTimestamp","errorMessage","onloadend","onabort","formData","FormData","fileName","multipart","multipartParams","multipart_params","_buildUrl","extend","_toError","hardwareConcurrency","listing_id","lot","dbSave","prepend","processed","filters","onBeforeQueue","onPreviewThumbnail","$canvas","progress","stats","onAllUploadsComplete","onError","major","device","sprint","model","vendor","HTC","Sprint","ME","XP","Vista","RT","AVATAR_URL","queueManager","generateAll","_preload","_process","_avatar","error_avatar","$thumb","_resolution","embed","fit","ext","pop","toUpperCase","searchParams","fallbackFile","custom","o","resolution","TypeError","crypto","randomUUID","_toExt","_file","lastModifiedDate","createdDate","start","end","contentType","_preTransport","rawHeaders","headers","line","parts","shift","_a","magic_data_json_1","_isSourcedFile","bytes","_matchMagic","_bytesToHex","from","padStart","headerBytes","hex","magic","MAGIC_DATA","_test","prefix","entry","startsWith","_toMagic","__toMagicTuple","arr","extension","description","extension_only","multi_part","footers","nested","innerKey","fileProcessor_lib_1","registry_1","imageReader_lib_1","uploadPipeline_lib_1","fileProcessor","FileProcessor","pipeline","observeFilters","_registerPlugins","onInitialize","applyFilters","filtered","_onFilesFiltered","accepted","_files","_onBeforeQueue","handleAllUploadsComplete","filterResult","rejected","reason","selectedMimes","getSupportedMimes","plugins","PluginRegistry","getPlugins","UAParser","regex_data_1","uastring","_ua","navigator","userAgent","ua","getBrowser","rgx","getEngine","getOS","getResult","engine","MIME_TYPES","jpeg","jpg","jfif","png","webp","heic","heif","gif","bmp","avif","tiff","pageData","canceled","readyState","abort","getFile","items","query","encodeURIComponent","ms","parsed","__parseError","details","fallback","util","str1","str2","_args","j","q","matches","arguments","regex","arg1","arg2","arg3","sub","IMAGE_EVENT_TYPES","feature_lib_2","useCache","image","_events","meta","exif","_hydrate","_decode","clone","clonedCanvas","_cloneCanvas","opts","multipass","includeBlob","srcCanvas","_imageToCanvas","_calcMaxDimensions","_cropCanvas","_multiPassScale","_scale","async","cacheKey","_cacheKey","_hasCache","_saveCache","_trigger","RESIZE","ERROR","element","querySelector","HTMLElement","thumb","_getMetaThumbnail","getCanvas","innerHTML","appendChild","EMBEDDED","_releaseCanvas","getMetadata","getAsDataURL","qualityValue","normalizedQuality","toDataURL","preserveHeadersValue","_fixIOSCCanvas","naturalWidth","naturalHeight","LOAD","decodeOnFail","cacheEntry","_getCache","targetW","targetH","temp","final","tn","sx","sy","ow","oh","sw","sh","cropped","tgtRatio","cloned","body","contains","clearRect","h","w","getImageData","transparent","exifBlob","resized","cached","_cache","hashBuffer","subtle","digest","_uuid","c","random","evt","evts","_evts","eventName","event","list","EVENT_TYPES","uaparser_lib_1","CSS","supports","style","getComputedStyle","removeChild","canSupportBlobs","canSupport32KbDataURI","OffscreenCanvas","uaResult","uaParser","osVersion","LOG_LEVEL","window_1","logLevel","INFO","fns","level","WARN","DEBUG","actual","loglevel","setLogLevel","_level","getLogLevel","info","_fileSignatures","_applyFilter","outcome","isPlainObject","mime_types","_mimeToExts","_getMimeTypes","prevent_duplicates","_isValidSignature","_isValidSize","_isValidMime","max_file_size","_parseFileSize","mimeTypes","fileMime","_getFileMime","hash","detectedMime","mimeGroups","_parseExtensions","flatMap","group","title","extensions","sExtensions","extList","mimeValueSet","units","kb","mb","gb","tb","pb","unit","_mimeTypes","exts","concurrency","queue","taskFn","task","run","delete","_dequeue","pending","isIdle","checkIdle","DEPENDENCIES","SURLV","_loadScripts","urls","$attrs","_loadedScripts","script","setAttribute","head","__imageToCanvas","_CANVAS_SUPPORT","renderToCanvas","_AUTO_ROTATE","HTMLImageElement","ImageData","putImageData","ImageBitmap","resizeWidth","resizeHeight","resizeQuality","__canvasToBlob","convertToBlob","__canRunVips","initVips","_vips","crossOrigin","vipsOptions","locateFile","scriptDirectory","print","stdout","noImageDecoding","dynamicLibraries","preRun","module","setAutoDeleteLater","setDelayFunction","cleanup","postRun","pad","have","Utils","typeFind","padEnd","emscriptenVersion","Cache","maxMem","maxFiles","Stats","allocations","mem","memHighwater","printErr","text","Vips","preloadPlugins","_decodeAvif","jSquash","decoded","Uint8ClampedArray","jpegBuffer","encode","_decodeHeic","heic2any","toType","finally","_decodeBmp","nodeBuffer","bmpJs","Buffer","_decodeVips","supportedMimeTypes","imageBuffer","newFromBuffer","outputBytes","writeToBuffer","_equal","a","_registry","registry","handlers","counts","uploaded","failed","handler","index","splice","emit","targetElement","completed","queued","_calcTotalProgress","oProgress","ids","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}